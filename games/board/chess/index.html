<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess - No Spin Media</title>
  <link rel="stylesheet" href="/style.css">
  <style>
    /* Global body styles for the game theme */
    body {
      background: #222831; /* Deep charcoal for a calm background */
      color: #fff;
      margin: 0;
      font-family: 'Inter', Arial, sans-serif; /* Using Inter for a modern look */
      display: flex;
      flex-direction: column;
      min-height: 100vh; /* Ensure footer stays at bottom */
    }

    /* Main game container layout */
    #game-container {
      display: flex;
      justify-content: center;
      padding: 20px;
      gap: 30px;
      flex-wrap: wrap; /* Allows wrapping on smaller screens */
      flex-grow: 1; /* Allows container to grow and push footer down */
    }

    /* Game box styling (main game area) */
    #game-box {
      border: 2px solid #74B9FF; /* Muted blue border */
      box-shadow: 0 0 20px #74B9FF; /* Muted blue glow */
      padding: 15px;
      border-radius: 12px; /* More rounded corners */
      background: #222831; /* Match body background */
      position: relative; /* Important for absolute positioning of overlay */
      flex-grow: 1; /* Allows game box to take available space */
      max-width: 900px; /* Limit max width for better readability */
      min-width: 320px; /* Minimum width for mobile */
      display: flex;
      flex-direction: column;
    }

    /* Game header styling */
    #game-header {
      color: #74B9FF; /* Muted blue header text */
      text-align: center;
      font-size: 2.2em; /* Slightly larger title */
      margin-bottom: 10px;
      text-shadow: 0 0 10px #74B9FF;
      position: relative;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(116, 185, 255, 0.3); /* Subtle separator with new color */
    }

    #game-version {
      position: absolute;
      top: 5px;
      right: 15px;
      color: #74B9FF;
      font-size: 0.7em; /* Smaller version text */
      opacity: 0.7;
    }

    /* Game info (current turn, messages) */
    #game-info {
      text-align: center;
      color: #74B9FF; /* Muted blue info text */
      margin-bottom: 15px;
      font-weight: bold;
      font-size: 1.1em;
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      gap: 10px;
    }
    #game-info span {
      padding: 5px 10px;
      background: rgba(116, 185, 255, 0.1); /* Subtle background with new color */
      border-radius: 5px;
    }

    /* Game controls/buttons */
    .game-controls {
      text-align: center;
      margin-bottom: 20px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .game-controls button {
      padding: 10px 20px;
      margin: 0 5px;
      background: #60A3D9; /* Calming blue buttons */
      color: #000;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 1.1em;
      box-shadow: 0 0 10px rgba(96, 163, 217, 0.5);
      transition: all 0.2s ease-in-out;
    }

    .game-controls button:hover {
      background: #7ABCEF; /* Lighter blue on hover */
      box-shadow: 0 0 15px rgba(122, 188, 239, 0.8);
      transform: translateY(-2px);
    }

    .game-controls button:active {
      transform: translateY(0);
      box-shadow: 0 0 5px rgba(96, 163, 217, 0.3);
    }

    /* Game mode dropdown */
    .game-controls select {
        padding: 10px 15px;
        border-radius: 8px;
        border: 1px solid #60A3D9;
        background-color: #2E4057; /* Darker blue for dropdown background */
        color: #fff;
        font-size: 1.1em;
        cursor: pointer;
        outline: none;
        box-shadow: 0 0 10px rgba(96, 163, 217, 0.3);
        transition: border-color 0.2s, box-shadow 0.2s;
    }

    .game-controls select:hover {
        border-color: #7ABCEF;
        box-shadow: 0 0 15px rgba(122, 188, 239, 0.5);
    }


    /* Sidebar styling (Donate section) */
    #sidebar {
      background: #222831; /* Match body background */
      border: 2px solid #74B9FF; /* Muted blue border */
      box-shadow: 0 0 15px #74B9FF; /* Muted blue glow */
      padding: 20px;
      border-radius: 8px;
      max-width: 280px; /* Slightly wider sidebar */
      height: fit-content;
      text-align: center;
      margin-top: 15px; /* Align with game box top */
    }

    #sidebar h2 {
      color: #74B9FF; /* Muted blue header */
      text-align: center;
      margin-bottom: 15px;
    }

    #donate-button {
      background: #ffd700; /* Gold button (kept for donation distinction) */
      color: #000;
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin: 15px auto 10px; /* More margin */
      display: block;
      transition: all 0.2s ease-in-out;
    }

    #donate-button:hover {
      background: #ffe033;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
      transform: translateY(-2px);
    }

    #donate-button:active {
      transform: translateY(0);
      box-shadow: 0 0 5px rgba(96, 163, 217, 0.3);
    }

    #sidebar p {
      font-size: 0.9em;
      color: #aaa;
      line-height: 1.4;
    }

    /* Footer styling */
    footer {
      text-align: center;
      color: #666;
      padding: 15px;
      font-size: 0.9em;
      margin-top: auto; /* Pushes footer to the bottom */
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* --- Chess Board Specific Layout --- */
    #chess-board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      width: 560px; /* 8 * 70px per square */
      height: 560px; /* 8 * 70px per square */
      margin: 20px auto;
      border: 4px solid #74B9FF; /* Muted blue border for the board */
      box-shadow: 0 0 25px rgba(116, 185, 255, 0.5);
      border-radius: 8px;
      overflow: hidden; /* Ensures pieces don't overflow board corners */
      position: relative; /* Crucial for positioning the overlay inside */
    }

    .square {
      width: 70px;
      height: 70px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 4em; /* Large enough for Unicode pieces */
      cursor: pointer;
      transition: background-color 0.2s ease-in-out;
      position: relative; /* For piece positioning */
    }

    .light {
      background-color: #AEC6CF; /* Light blue-grey */
    }

    .dark {
      background-color: #4A6572; /* Calm blue-grey */
    }

    .selected {
      background-color: #4682B4; /* SteelBlue for selected piece */
      box-shadow: inset 0 0 10px #4682B4;
    }

    .possible-move {
      background-color: #87CEEB; /* SkyBlue for possible moves */
      box-shadow: inset 0 0 10px #87CEEB;
    }

    .piece {
      user-select: none; /* Prevent text selection on pieces */
      font-size: 0.9em; /* Adjust font size for piece symbols */
      line-height: 1; /* Ensure vertical centering */
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.2s ease-in-out; /* Smooth movement */
    }

    .piece.white {
      color: #F8F8F8; /* Off-white for white pieces */
    }

    .piece.black {
      color: #333333; /* Dark grey for black pieces */
    }

    /* Game message box (for all messages) */
    #game-message {
      position: relative; /* Stays above the board */
      margin: 10px auto;
      background: rgba(0,0,0,0.8);
      padding: 10px 20px;
      border-radius: 8px;
      border: 2px solid #74B9FF;
      color: #74B9FF; /* Default color for in-game messages */
      font-size: 1.5em; /* Default size for in-game messages */
      font-weight: bold;
      text-shadow: 0 0 5px #74B9FF;
      display: none;
      text-align: center;
      width: fit-content;
      max-width: 80%;
      z-index: 1001; /* High z-index */
    }

    /* Style for game over message */
    #game-message.game-over-style {
      color: #FFD700; /* Gold color for game over text */
      font-size: 2.5em; /* Larger font for game over */
      text-shadow: 0 0 20px #FFD700; /* Stronger glow */
      padding: 20px 30px; /* More padding for prominence */
    }

    /* Highlight for captured square */
    .captured-square-highlight {
        animation: capturedFlash 0.5s ease-out 2 alternate; /* Flash yellow twice */
    }

    @keyframes capturedFlash {
        from { background-color: inherit; }
        to { background-color: #FFD700; /* Gold color for flash */ }
    }


    /* Responsive adjustments */
    @media (max-width: 768px) {
      #game-container {
        flex-direction: column;
        align-items: center;
        padding: 10px;
      }
      #game-box {
        width: 100%;
        max-width: none;
        padding: 10px;
      }
      #sidebar {
        width: 100%;
        max-width: none;
        margin-top: 20px;
      }
      #chess-board {
        width: 90vw; /* Make board responsive */
        height: 90vw;
        max-width: 500px; /* Cap max size */
        max-height: 500px;
      }
      .square {
        width: 12.5vw; /* 100vw / 8 squares */
        height: 12.5vw;
        font-size: 10vw; /* Adjust piece size responsively */
      }
      .game-controls button {
        font-size: 1em;
        padding: 8px 15px;
      }
      #game-header {
        font-size: 1.8em;
      }
      #game-info span {
        font-size: 0.9em;
      }
      #game-message {
        font-size: 1.2em; /* Smaller on mobile */
        padding: 8px 15px;
      }
      #game-message.game-over-style {
        font-size: 1.8em; /* Smaller on mobile for game over */
        padding: 15px 20px;
      }
    }
  </style>
</head>
<body>

  <!-- Site-wide header (fetched dynamically) -->
  <div id="site-header"></div>
  <script>
    fetch(window.location.origin + '/header.html')
      .then(r => r.text())
      .then(h => document.getElementById('site-header').innerHTML = h)
      .catch(e => console.error('Error fetching header:', e));
  </script>

  <div id="game-container">
    <div id="game-box">
      <div id="game-header">Chess ‚ôüÔ∏è <span id="game-version">v2.5</span></div>
      <div id="game-info">
        <span>Current Turn: <span id="current-turn">White</span></span>
        <span>White Score: <span id="white-score">0</span></span>
        <span>Black Score: <span id="black-score">0</span></span>
      </div>

      <div class="game-controls">
        <button id="newGameBtn">‚ú® New Game</button>
        <select id="gameModeSelect">
            <option value="playComputer">Play Computer</option>
            <option value="watchAI">Watch AI</option>
        </select>
        <button id="shareBtn">üîó Share with Friends</button>
        <button id="copyBtn">üìã Copy Link</button>
      </div>

      <!-- Game message box for all notifications, including game over -->
      <div id="game-message"></div>

      <div id="chess-board">
        <!-- Squares and pieces will be dynamically generated here -->
      </div>
    </div>

    <!-- Sidebar (Donate section) -->
    <div id="sidebar">
      <h2>Support Us!</h2>
      <p>If you enjoy ad-free games from No Spin Media, consider supporting us.</p>
      <button id="donate-button" onclick="window.location.href='/sponsor.html'">Donate Now</button>
      <p style="font-size:0.8em; color:#aaa;">Your help keeps No Spin Media alive and growing.</p>
    </div>
  </div>

  <!-- Site-wide footer -->
  <footer style="text-align:center;color:#666;padding:10px;">
    ¬© 2025 No Spin Media. Independent. Ad-free. Truth-focused.
  </footer>

  <script>
    // --- Game State Variables ---
    const pieceSymbols = {
      'p': '‚ôô', 'r': '‚ôñ', 'n': '‚ôò', 'b': '‚ôó', 'q': '‚ôï', 'k': '‚ôî', // White pieces
      'P': '‚ôü', 'R': '‚ôú', 'N': '‚ôû', 'B': '‚ôù', 'Q': '‚ôõ', 'K': '‚ôö'  // Black pieces
    };

    // Define piece values for scoring
    const pieceValues = {
        'p': 10, 'r': 50, 'n': 30, 'b': 30, 'q': 90, 'k': 0, // White pieces (King has 0 value for capture scoring)
        'P': 10, 'R': 50, 'N': 30, 'B': 30, 'Q': 90, 'K': 0  // Black pieces
    };

    let board = []; // 8x8 array representing the chessboard
    let currentTurn = 'white'; // 'white' or 'black'
    let selectedPiece = null; // { row, col, piece } of the selected piece
    let possibleMoves = []; // Array of { row, col } for valid moves for selected piece
    let whiteScore = 0; // Initialize white player's score
    let blackScore = 0; // Initialize black player's score
    let gameMode = 'playComputer'; // 'playComputer' or 'watchAI'
    let aiMoveTimeoutId = null; // To store the timeout ID for AI moves
    let gameEnded = false; // Flag to indicate if the game has ended
    let messageTimeoutId = null; // New: To manage the hide timeout for temporary messages

    // --- DOM Elements ---
    const chessBoardEl = document.getElementById('chess-board');
    const currentTurnEl = document.getElementById('current-turn');
    const whiteScoreEl = document.getElementById('white-score'); // Get white score element
    const blackScoreEl = document.getElementById('black-score'); // Get black score element
    const gameMessageEl = document.getElementById('game-message'); // For all messages
    const newGameBtn = document.getElementById('newGameBtn');
    const gameModeSelect = document.getElementById('gameModeSelect'); // New DOM element

    // --- Game Initialization ---
    function initializeGame() {
      currentTurn = 'white';
      selectedPiece = null;
      possibleMoves = [];
      whiteScore = 0; // Reset score on new game
      blackScore = 0; // Reset score on new game
      gameEnded = false; // Reset game ended flag
      hideGameMessage(); // Ensure message is hidden on new game
      renderBoard();
      updateHUD();
      stopAIGameLoop(); // Ensure any previous AI loop is stopped

      if (gameMode === 'watchAI') {
        // Start the AI vs AI loop
        makeAIMoveForColor(currentTurn); // Start with white AI
      }
    }

    // --- Board Representation and Setup ---
    function setupInitialBoard() {
      // Initialize empty board
      board = Array(8).fill(null).map(() => Array(8).fill(null));

      // Set up black pieces (uppercase for black)
      board[0][0] = { type: 'R', color: 'black' }; // Rook
      board[0][1] = { type: 'N', color: 'black' }; // Knight
      board[0][2] = { type: 'B', color: 'black' }; // Bishop
      board[0][3] = { type: 'Q', color: 'black' }; // Queen
      board[0][4] = { type: 'K', color: 'black' }; // King
      board[0][5] = { type: 'B', color: 'black' }; // Bishop
      board[0][6] = { type: 'N', color: 'black' }; // Knight
      board[0][7] = { type: 'R', color: 'black' }; // Rook
      for (let i = 0; i < 8; i++) {
        board[1][i] = { type: 'P', color: 'black' }; // Pawns
      }

      // Set up white pieces (lowercase for white)
      board[7][0] = { type: 'r', color: 'white' }; // Rook
      board[7][1] = { type: 'n', color: 'white' }; // Knight
      board[7][2] = { type: 'b', color: 'white' }; // Bishop
      board[7][3] = { type: 'q', color: 'white' }; // Queen
      board[7][4] = { type: 'k', color: 'white' }; // King
      board[7][5] = { type: 'b', color: 'white' }; // Bishop
      board[7][6] = { type: 'n', color: 'white' }; // Knight
      board[7][7] = { type: 'r', color: 'white' }; // Rook
      for (let i = 0; i < 8; i++) {
        board[6][i] = { type: 'p', color: 'white' }; // Pawns
      }
    }

    // --- Rendering Functions ---
    function renderBoard() {
      chessBoardEl.innerHTML = ''; // Clear existing board
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const squareEl = document.createElement('div');
          squareEl.classList.add('square');
          squareEl.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
          squareEl.dataset.row = r;
          squareEl.dataset.col = c;

          const piece = board[r][c];
          if (piece) {
            const pieceEl = document.createElement('span');
            pieceEl.classList.add('piece', piece.color);
            pieceEl.textContent = pieceSymbols[piece.type];
            squareEl.appendChild(pieceEl);
          }

          // Add click listener to each square
          squareEl.addEventListener('click', handleSquareClick);
          chessBoardEl.appendChild(squareEl);
        }
      }
      highlightSelectedAndPossibleMoves();
    }

    function highlightSelectedAndPossibleMoves() {
      document.querySelectorAll('.square').forEach(squareEl => {
        squareEl.classList.remove('selected', 'possible-move');
      });

      if (selectedPiece) {
        const selectedEl = document.querySelector(`.square[data-row="${selectedPiece.row}"][data-col="${selectedPiece.col}"]`);
        if (selectedEl) {
          selectedEl.classList.add('selected');
        }

        possibleMoves.forEach(move => {
          const moveEl = document.querySelector(`.square[data-row="${move.row}"][data-col="${move.col}"]`);
          if (moveEl) {
            moveEl.classList.add('possible-move');
          }
        });
      }
    }

    function updateHUD() {
      let turnText = currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1);
      if (gameMode === 'playComputer') {
        turnText += ` (Human vs AI)`;
      } else if (gameMode === 'watchAI') {
        turnText += ` (AI vs AI)`;
      }
      currentTurnEl.textContent = turnText;
      whiteScoreEl.textContent = whiteScore; // Update white score display
      blackScoreEl.textContent = blackScore; // Update black score display
    }

    // Function to display messages. If isGameOver is true, message persists.
    function displayGameMessage(message, isGameOver = false) {
      // Clear any existing timeout for temporary messages
      clearTimeout(messageTimeoutId);
      messageTimeoutId = null; // Reset it

      gameMessageEl.textContent = message;
      gameMessageEl.style.display = 'block';
      if (isGameOver) {
        gameMessageEl.classList.add('game-over-style'); // Add style for game over
      } else {
        gameMessageEl.classList.remove('game-over-style'); // Remove style for temporary messages
        // Schedule hiding only for temporary messages
        messageTimeoutId = setTimeout(hideGameMessage, 2000);
      }
    }

    function hideGameMessage() {
      gameMessageEl.style.display = 'none';
      gameMessageEl.classList.remove('game-over-style'); // Ensure style is removed when hidden
    }

    function endGame(winnerColor = null) {
        gameEnded = true;
        stopAIGameLoop();
        // New: Clear any pending temporary message hide timeout when game ends
        clearTimeout(messageTimeoutId);
        messageTimeoutId = null;

        if (winnerColor) {
            displayGameMessage(`${winnerColor.toUpperCase()} wins by King capture!`, true); // True for persistent message
        } else {
            const noMovesPlayer = currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1);
            displayGameMessage(`Game over! ${noMovesPlayer} has no legal moves.`, true); // True for persistent message
        }
    }

    // --- Game Logic: Piece Movement Validation (Simplified for v1.0) ---
    // NOTE: This is a highly simplified validation. It does not account for:
    // - Blocking pieces between source and destination (except for pawns).
    // - Check/Checkmate logic.
    // - Castling, En Passant, Pawn Promotion.
    // These are complex and would be added in future versions.
    function getPossibleMoves(row, col, piece) {
      const moves = [];
      const pieceColor = piece.color;
      const opponentColor = pieceColor === 'white' ? 'black' : 'white';

      // Helper function to check if a square is valid and not occupied by own piece
      const isValidSquare = (r, c) => {
        return r >= 0 && r < 8 && c >= 0 && c < 8 && (!board[r][c] || board[r][c].color !== pieceColor);
      };

      // Helper for sliding pieces (Rook, Bishop, Queen)
      const addSlidingMoves = (dr, dc) => {
        let r = row + dr;
        let c = col + dc;
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          if (!board[r][c]) { // Empty square
            moves.push({ row: r, col: c });
          } else if (board[r][c].color !== pieceColor) { // Opponent's piece (capture)
            moves.push({ row: r, col: c });
            break; // Stop after capturing
          } else { // Own piece (blocking)
            break;
          }
          r += dr;
          c += dc;
        }
      };

      switch (piece.type.toLowerCase()) {
        case 'p': // Pawn
          const direction = pieceColor === 'white' ? -1 : 1; // White moves up, black moves down
          const startRow = pieceColor === 'white' ? 6 : 1;

          // Single step forward
          if (board[row + direction] && !board[row + direction][col]) {
            moves.push({ row: row + direction, col: col });
            // Double step forward on first move
            if (row === startRow && !board[row + 2 * direction][col]) {
              moves.push({ row: row + 2 * direction, col: col });
            }
          }
          // Diagonal captures
          if (col - 1 >= 0 && board[row + direction] && board[row + direction][col - 1] && board[row + direction][col - 1].color === opponentColor) {
            moves.push({ row: row + direction, col: col - 1 });
          }
          if (col + 1 < 8 && board[row + direction] && board[row + direction][col + 1] && board[row + direction][col + 1].color === opponentColor) {
            moves.push({ row: row + direction, col: col + 1 });
          }
          break;
        case 'r': // Rook
          addSlidingMoves(1, 0); addSlidingMoves(-1, 0); // Vertical
          addSlidingMoves(0, 1); addSlidingMoves(0, -1); // Horizontal
          break;
        case 'n': // Knight
          const knightMoves = [
            { dr: -2, dc: -1 }, { dr: -2, dc: 1 }, { dr: -1, dc: -2 }, { dr: -1, dc: 2 },
            { dr: 1, dc: -2 }, { dr: 1, dc: 2 }, { dr: 2, dc: -1 }, { dr: 2, dc: 1 }
          ];
          knightMoves.forEach(move => {
            const newRow = row + move.dr;
            const newCol = col + move.dc;
            if (isValidSquare(newRow, newCol)) {
              moves.push({ row: newRow, col: newCol });
            }
          });
          break;
        case 'b': // Bishop
          addSlidingMoves(1, 1); addSlidingMoves(1, -1); // Diagonal
          addSlidingMoves(-1, 1); addSlidingMoves(-1, -1); // Diagonal
          break;
        case 'q': // Queen (Rook + Bishop)
          addSlidingMoves(1, 0); addSlidingMoves(-1, 0); // Vertical
          addSlidingMoves(0, 1); addSlidingMoves(0, -1); // Horizontal
          addSlidingMoves(1, 1); addSlidingMoves(1, -1); // Diagonal
          addSlidingMoves(-1, 1); addSlidingMoves(-1, -1); // Diagonal
          break;
        case 'k': // King
          const kingMoves = [
            { dr: -1, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: 1 },
            { dr: 0, dc: -1 }, { dr: 0, dc: 1 },
            { dr: 1, dc: -1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 }
          ];
          kingMoves.forEach(move => {
            const newRow = row + move.dr;
            const newCol = col + move.dc;
            if (isValidSquare(newRow, newCol)) {
              moves.push({ row: newRow, col: newCol });
            }
          });
          break;
      }
      return moves;
    }

    // --- AI Logic (Basic Random Move for a given color) ---
    function makeAIMoveForColor(playerColor) {
      // Clear any previous timeout to prevent multiple AI moves overlapping
      clearTimeout(aiMoveTimeoutId);

      if (gameEnded || currentTurn !== playerColor) return; // Only move if it's this AI's turn and game is not ended

      displayGameMessage(`${playerColor.charAt(0).toUpperCase() + playerColor.slice(1)}'s Turn (AI thinking...)`);

      aiMoveTimeoutId = setTimeout(() => {
        let allPossibleAIMoves = [];

        // Collect all valid moves for the current AI's pieces
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const piece = board[r][c];
            if (piece && piece.color === playerColor) {
              const movesForPiece = getPossibleMoves(r, c, piece);
              movesForPiece.forEach(move => {
                allPossibleAIMoves.push({
                  fromRow: r,
                  fromCol: c,
                  toRow: move.row,
                  toCol: move.col,
                  piece: piece
                });
              });
            }
          }
        }

        if (allPossibleAIMoves.length > 0) {
          // Pick a random valid move
          const randomMove = allPossibleAIMoves[Math.floor(Math.random() * allPossibleAIMoves.length)];

          // Check for capture and update score
          const capturedPiece = board[randomMove.toRow][randomMove.toCol];
          if (capturedPiece) {
              if (playerColor === 'white') {
                  whiteScore += pieceValues[capturedPiece.type];
              } else { // black captures white
                  blackScore += pieceValues[capturedPiece.type.toLowerCase()];
              }
          }

          // Perform the move
          board[randomMove.toRow][randomMove.toCol] = randomMove.piece; // Move piece
          board[randomMove.fromRow][randomMove.fromCol] = null; // Clear old position

          // Render the board first to update DOM
          renderBoard();
          updateHUD();

          // Highlight captured square if a piece was captured
          if (capturedPiece) {
              const targetSquareEl = document.querySelector(`.square[data-row="${randomMove.toRow}"][data-col="${randomMove.toCol}"]`);
              if (targetSquareEl) {
                  targetSquareEl.classList.add('captured-square-highlight');
                  setTimeout(() => {
                      targetSquareEl.classList.remove('captured-square-highlight');
                  }, 1000); // Highlight for 1 second
              }
          }

          // Check if a King was captured (simple win condition)
          if (capturedPiece && capturedPiece.type.toLowerCase() === 'k') {
              // Add a small delay before calling endGame to allow for render and highlight
              setTimeout(() => endGame(playerColor), 100);
              return; // Stop further processing as game has ended
          }

          // Only display "X made a move!" if the game hasn't ended (this check is crucial)
          if (!gameEnded) {
            currentTurn = playerColor === 'white' ? 'black' : 'white';
            displayGameMessage(`${playerColor.charAt(0).toUpperCase() + playerColor.slice(1)} made a move!`);
          }


          // If in Watch AI mode, trigger the next AI move
          if (gameMode === 'watchAI' && !gameEnded) { // gameEnded check is still needed here
              makeAIMoveForColor(currentTurn);
          }

        } else {
          endGame(); // No moves for current player, game over
        }
      }, 1000); // 1 second delay for AI move
    }

    function stopAIGameLoop() {
        clearTimeout(aiMoveTimeoutId);
        aiMoveTimeoutId = null;
    }


    // --- Event Handlers ---
    function handleSquareClick(event) {
      if (gameEnded) {
        displayGameMessage("Game has ended. Start a New Game!"); // Still display this temporary message
        return;
      }

      if (gameMode === 'watchAI') {
        displayGameMessage("In 'Watch AI' mode, you cannot move pieces.");
        return;
      }

      if (currentTurn === 'black') { // This is for 'playComputer' mode, when it's AI's turn
        displayGameMessage("It's Black's turn (AI). Please wait.");
        return;
      }

      const clickedRow = parseInt(event.currentTarget.dataset.row);
      const clickedCol = parseInt(event.currentTarget.dataset.col);
      const clickedPiece = board[clickedRow][clickedCol];

      // If a piece is already selected
      if (selectedPiece) {
        // Check if clicked square is a valid move for the selected piece
        const isValidMove = possibleMoves.some(move => move.row === clickedRow && move.col === clickedCol);

        if (isValidMove) {
          // Check for capture and update score
          const capturedPiece = board[clickedRow][clickedCol];
          if (capturedPiece) {
              whiteScore += pieceValues[capturedPiece.type]; // Add score for captured piece (White's perspective)
          }

          // Perform the move
          board[clickedRow][clickedCol] = selectedPiece.piece; // Move piece
          board[selectedPiece.row][selectedPiece.col] = null; // Clear old position

          // Render the board first to update DOM
          renderBoard();
          updateHUD();

          // Highlight captured square if a piece was captured
          if (capturedPiece) {
              const targetSquareEl = document.querySelector(`.square[data-row="${clickedRow}"][data-col="${clickedCol}"]`);
              if (targetSquareEl) {
                  targetSquareEl.classList.add('captured-square-highlight');
                  setTimeout(() => {
                      targetSquareEl.classList.remove('captured-square-highlight');
                  }, 1000); // Highlight for 1 second
              }
          }

          // Check if opponent's King was captured (simple win condition)
          if (capturedPiece && capturedPiece.type.toLowerCase() === 'k') {
              // Add a small delay before calling endGame to allow for render and highlight
              setTimeout(() => endGame('white'), 100);
              return; // Stop further processing as game has ended
          }

          // Only display "X made a move!" if the game hasn't ended (this check is crucial)
          if (!gameEnded) {
            selectedPiece = null;
            possibleMoves = [];
            currentTurn = 'black'; // Switch to black (AI)
            displayGameMessage("White made a move!");
          }


          // If it's now Black's turn, trigger AI move
          if (currentTurn === 'black' && !gameEnded) {
            makeAIMoveForColor(currentTurn);
          }

        } else if (clickedPiece && clickedPiece.color === currentTurn) {
          // Clicked on a different piece of the current player's color
          selectedPiece = { row: clickedRow, col: clickedCol, piece: clickedPiece };
          possibleMoves = getPossibleMoves(clickedRow, clickedCol, clickedPiece);
          renderBoard(); // Re-render to highlight new selection
        } else {
          // Invalid move or clicked on opponent's piece/empty square (deselect)
          selectedPiece = null;
          possibleMoves = [];
          renderBoard();
          displayGameMessage("Invalid move or deselected.");
        }
      } else {
        // No piece selected, try to select one
        if (clickedPiece && clickedPiece.color === currentTurn) {
          selectedPiece = { row: clickedRow, col: clickedCol, piece: clickedPiece };
          possibleMoves = getPossibleMoves(clickedRow, clickedCol, clickedPiece);
          renderBoard(); // Highlight selected piece and possible moves
        } else if (clickedPiece && clickedPiece.color !== currentTurn) {
          displayGameMessage("It's not your turn!");
        } else {
          displayGameMessage("Select a piece to move.");
        }
      }
    }

    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', () => {
      newGameBtn.addEventListener('click', () => {
        setupInitialBoard(); // Reset board to initial state
        initializeGame(); // Re-initialize game state
        displayGameMessage("New Game Started!");
      });

      gameModeSelect.addEventListener('change', (event) => {
        gameMode = event.target.value;
        setupInitialBoard(); // Reset board for new mode
        initializeGame(); // Re-initialize game state based on new mode
        displayGameMessage(`Mode changed to: ${gameMode === 'playComputer' ? 'Play Computer' : 'Watch AI'}`);
      });

      // Share and Copy Link buttons
      // NOTE: document.execCommand('copy') is deprecated. For better compatibility,
      // consider using navigator.clipboard.writeText if running in a secure context.
      // For this Canvas environment, execCommand might be more reliable.
      document.getElementById('shareBtn').onclick = () => {
        if (navigator.share) {
          navigator.share({
            title: "Chess - No Spin Media",
            url: window.location.href
          }).catch((error) => console.error('Error sharing:', error));
        } else {
          // Fallback for copying to clipboard
          const dummyTextArea = document.createElement('textarea');
          dummyTextArea.value = window.location.href;
          document.body.appendChild(dummyTextArea);
          dummyTextArea.select();
          document.execCommand('copy');
          document.body.removeChild(dummyTextArea);
          displayGameMessage("Link copied to clipboard!");
        }
      };
      document.getElementById('copyBtn').onclick = () => {
        const dummyTextArea = document.createElement('textarea');
        dummyTextArea.value = window.location.href;
        document.body.appendChild(dummyTextArea);
        dummyTextArea.select();
        document.execCommand('copy');
        document.body.removeChild(dummyTextArea);
        displayGameMessage("Link copied to clipboard!");
      };

      // Initial game setup when page loads
      setupInitialBoard();
      initializeGame();
    });
  </script>
</body>
</html>
