<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Klondike Solitaire - No Spin Media</title>
  <!-- Link to your existing global stylesheet -->
  <link rel="stylesheet" href="/style.css">
  <style>
    /* Global body styles for the game theme */
    body {
      background: #000; /* Black background like the space game */
      color: #fff;
      margin: 0;
      font-family: 'Inter', Arial, sans-serif; /* Using Inter for a modern look */
      display: flex;
      flex-direction: column;
      min-height: 100vh; /* Ensure footer stays at bottom */
    }

    /* Main game container layout */
    #game-container {
      display: flex;
      justify-content: center;
      padding: 20px;
      gap: 30px;
      flex-wrap: wrap; /* Allows wrapping on smaller screens */
      flex-grow: 1; /* Allows container to grow and push footer down */
    }

    /* Game box styling (main game area) */
    #game-box {
      border: 2px solid #0f0; /* Green border */
      box-shadow: 0 0 20px #0f0; /* Green glow */
      padding: 15px;
      border-radius: 12px; /* More rounded corners */
      background: #000;
      position: relative;
      flex-grow: 1; /* Allows game box to take available space */
      max-width: 900px; /* Limit max width for better readability */
      min-width: 320px; /* Minimum width for mobile */
      display: flex;
      flex-direction: column;
    }

    /* Game header styling */
    #game-header {
      color: #0f0;
      text-align: center;
      font-size: 2.2em; /* Slightly larger title */
      margin-bottom: 10px;
      text-shadow: 0 0 10px #0f0;
      position: relative;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(0, 255, 0, 0.3); /* Subtle separator */
    }

    #game-version {
      position: absolute;
      top: 5px;
      right: 15px;
      color: #0f0;
      font-size: 0.7em; /* Smaller version text */
      opacity: 0.7;
    }

    /* Game info (score, moves, time) */
    #game-info {
      text-align: center;
      color: #0f0;
      margin-bottom: 15px;
      font-weight: bold;
      font-size: 1.1em;
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      gap: 10px;
    }
    #game-info span {
      padding: 5px 10px;
      background: rgba(0, 255, 0, 0.1);
      border-radius: 5px;
    }

    /* Game controls/buttons */
    .game-controls {
      text-align: center;
      margin-bottom: 20px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .game-controls button {
      padding: 10px 20px;
      margin: 0 5px;
      background: #0f0; /* Green buttons */
      color: #000;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 1.1em;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      transition: all 0.2s ease-in-out;
    }

    .game-controls button:hover {
      background: #0aff0a;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
      transform: translateY(-2px);
    }

    .game-controls button:active {
      transform: translateY(0);
      box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
    }

    /* Sidebar styling (Donate section) */
    #sidebar {
      background: #111;
      border: 2px solid #0f0;
      box-shadow: 0 0 15px #0f0;
      padding: 20px;
      border-radius: 8px;
      max-width: 280px; /* Slightly wider sidebar */
      height: fit-content;
      text-align: center;
      margin-top: 15px; /* Align with game box top */
    }

    #sidebar h2 {
      color: #0f0;
      text-align: center;
      margin-bottom: 15px;
    }

    #donate-button {
      background: #ffd700; /* Gold button */
      color: #000;
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin: 15px auto 10px; /* More margin */
      display: block;
      transition: all 0.2s ease-in-out;
    }

    #donate-button:hover {
      background: #ffe033;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
      transform: translateY(-2px);
    }

    #donate-button:active {
      transform: translateY(0);
      box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
    }

    #sidebar p {
      font-size: 0.9em;
      color: #aaa;
      line-height: 1.4;
    }

    /* Footer styling */
    footer {
      text-align: center;
      color: #666;
      padding: 15px;
      font-size: 0.9em;
      margin-top: auto; /* Pushes footer to the bottom */
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* --- Klondike Specific Layout --- */
    #klondike-board {
      background-color: #006400; /* Dark green felt */
      border: 2px solid #0a0;
      border-radius: 10px;
      padding: 20px;
      display: grid;
      gap: 15px;
      grid-template-rows: auto 1fr; /* Top row for stock/waste/foundations, then tableau */
      flex-grow: 1; /* Allow board to fill remaining space */
      min-height: 400px; /* Minimum height for the board */
    }

    #top-area {
      display: flex;
      justify-content: space-between;
      gap: 15px;
      margin-bottom: 20px;
    }

    .pile-container {
      border: 1px dashed rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      min-width: 80px; /* Standard card width */
      height: 110px; /* Standard card height */
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 0.8em;
      color: rgba(255, 255, 255, 0.5);
      /* overflow: hidden; Removed for waste pile fix */
    }

    /* Specific styling for the waste pile container to allow cards to stack horizontally */
    #waste-pile {
        display: flex; /* Use flexbox for horizontal stacking */
        align-items: flex-start; /* Align cards to the top */
        overflow: visible; /* Ensure cards are not cut off */
        padding-left: 5px; /* Small padding to prevent cutting off first card if it's right on the border */
    }
    #waste-pile .card {
        position: relative; /* Change to relative for flexbox positioning */
        left: auto; /* Reset left property */
        top: auto; /* Reset top property */
        margin-left: -70px; /* Overlap cards, showing only a small portion of previous cards */
        flex-shrink: 0; /* Prevent cards from shrinking */
    }
    #waste-pile .card:first-child {
        margin-left: 0; /* No margin for the first card */
    }


    #foundations {
      display: flex;
      gap: 15px;
    }

    #tableau {
      display: grid;
      grid-template-columns: repeat(7, 1fr); /* 7 tableau piles */
      gap: 15px;
      align-items: start; /* Align piles to the top */
    }

    .tableau-pile {
      border: 1px dashed rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      min-width: 80px;
      min-height: 110px; /* Initial height for empty pile */
      position: relative;
      padding-top: 5px; /* Space for stacked cards */
      overflow: visible; /* Allow cards to extend beyond initial pile height */
    }

    /* Card Styling */
    .card {
      width: 80px;
      height: 110px;
      border-radius: 8px;
      background-color: #fff;
      border: 1px solid #333;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
      position: absolute; /* For stacking in tableau/foundations */
      cursor: grab; /* Indicate draggable */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      font-weight: bold;
      font-size: 1.2em;
      color: #000;
      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
      user-select: none; /* Prevent text selection on cards */
      z-index: 1; /* Default z-index for cards */
    }

    .card.red {
      color: #f00;
    }

    .card-rank {
      font-size: 1.5em;
      line-height: 1;
    }

    .card-suit {
      font-size: 1.5em;
      line-height: 1;
    }

    .card-back {
      background-color: #00f; /* Blue back */
      background-image: linear-gradient(45deg, rgba(255,255,255,0.1) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.1) 75%, rgba(255,255,255,0.1) 100%),
                        linear-gradient(-45deg, rgba(255,255,255,0.1) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.1) 75%, rgba(255,255,255,0.1) 100%);
      background-size: 20px 20px;
      border: 1px solid #00a;
      box-shadow: inset 0 0 10px rgba(0, 0, 255, 0.5);
      color: transparent; /* Hide rank/suit on back */
      cursor: default; /* Not draggable */
    }

    /* Dragging styles */
    .card.dragging {
      opacity: 0.7;
      transform: scale(1.05);
      z-index: 1000; /* Bring dragged card to front */
      cursor: grabbing;
    }

    /* Drop target highlight */
    .pile-container.drag-over, .tableau-pile.drag-over {
      border: 2px dashed #0f0; /* Green highlight for valid drop targets */
      box-shadow: 0 0 15px #0f0;
    }


    /* Card stacking in tableau */
    .tableau-pile .card {
      position: absolute;
      left: 0;
      /* top will be set by JS based on cardIndex */
    }

    /* How to Play Modal */
    #how-to-play-modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 2000; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.9); /* Black w/ opacity */
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: #1a1a1a;
      margin: auto;
      padding: 30px;
      border: 2px solid #0f0;
      border-radius: 12px;
      width: 80%;
      max-width: 700px;
      box-shadow: 0 0 25px #0f0;
      position: relative;
      animation: fadeIn 0.3s ease-out;
    }

    .modal-content h2 {
      color: #0f0;
      text-align: center;
      margin-bottom: 20px;
      font-size: 2em;
    }

    .modal-content p, .modal-content ul {
      color: #ccc;
      font-size: 1.1em;
      line-height: 1.6;
      margin-bottom: 10px;
    }

    .modal-content ul {
      list-style-type: disc;
      margin-left: 20px;
      padding-left: 0;
    }

    .modal-content li {
      margin-bottom: 8px;
    }

    .close-button {
      color: #0f0;
      position: absolute;
      top: 15px;
      right: 25px;
      font-size: 35px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.2s;
    }

    .close-button:hover,
    .close-button:focus {
      color: #0aff0a;
      text-decoration: none;
      cursor: pointer;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }


    /* Responsive adjustments */
    @media (max-width: 768px) {
      #game-container {
        flex-direction: column;
        align-items: center;
        padding: 10px;
      }
      #game-box {
        width: 100%;
        max-width: none;
        padding: 10px;
      }
      #sidebar {
        width: 100%;
        max-width: none;
        margin-top: 20px;
      }
      #top-area, #foundations {
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }
      #tableau {
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); /* Adjust columns for smaller screens */
        gap: 10px;
      }
      .pile-container, .tableau-pile {
        min-width: 70px; /* Slightly smaller on small screens */
        height: 100px;
      }
      .card {
        width: 70px;
        height: 100px;
        font-size: 1.1em;
      }
      .card-rank, .card-suit {
        font-size: 1.3em;
      }
      .modal-content {
        width: 95%;
        padding: 15px;
      }
      .modal-content h2 {
        font-size: 1.5em;
      }
      .modal-content p, .modal-content ul {
        font-size: 0.9em;
      }
    }
  </style>
</head>
<body>

  <!-- Site-wide header (fetched dynamically) -->
  <div id="site-header"></div>
  <script>
    fetch(window.location.origin + '/header.html')
      .then(r => r.text())
      .then(h => document.getElementById('site-header').innerHTML = h)
      .catch(e => console.error('Error fetching header:', e));
  </script>

  <div id="game-container">
    <div id="game-box">
      <div id="game-header">Klondike Solitaire 🃏 <span id="game-version">v1.9</span></div>
      <div id="game-info">
        <span>Score: <span id="score">0</span></span>
        <span>Moves: <span id="moves">0</span></span>
        <span>Time: <span id="time">0:00</span></span>
      </div>

      <div class="game-controls">
        <button id="newGameBtn">✨ New Game</button>
        <button id="undoBtn">↩️ Undo</button>
        <button id="hintBtn">💡 Hint</button>
        <button id="howToPlayBtn">❓ How to Play</button>
        <button id="shareBtn">🔗 Share with Friends</button>
        <button id="copyBtn">📋 Copy Link</button>
      </div>

      <div id="klondike-board">
        <div id="top-area">
          <!-- Stock and Waste Pile -->
          <div style="display: flex; gap: 15px;">
            <div id="stock-pile" class="pile-container">
              <div class="card card-back" style="position: relative;"></div> <!-- Example card back -->
              <span id="stock-text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">Stock<br>Click to Draw</span>
            </div>
            <div id="waste-pile" class="pile-container">
              <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">Waste</span>
            </div>
          </div>

          <!-- Foundation Piles -->
          <div id="foundations">
            <div id="foundation-hearts" class="pile-container" data-suit="hearts">
              <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3em; color: #ADD8E6;">❤️</span>
            </div>
            <div id="foundation-diamonds" class="pile-container" data-suit="diamonds">
              <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3em; color: #ADD8E6;">♦️</span>
            </div>
            <div id="foundation-clubs" class="pile-container" data-suit="clubs">
              <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3em; color: #ADD8E6;">♣️</span>
            </div>
            <div id="foundation-spades" class="pile-container" data-suit="spades">
              <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3em; color: #ADD8E6;">♠️</span>
            </div>
          </div>
        </div>

        <!-- Tableau Piles -->
        <div id="tableau">
          <!-- These will be dynamically populated by JavaScript -->
          <div id="tableau-pile-0" class="tableau-pile" data-pile-index="0"></div>
          <div id="tableau-pile-1" class="tableau-pile" data-pile-index="1"></div>
          <div id="tableau-pile-2" class="tableau-pile" data-pile-index="2"></div>
          <div id="tableau-pile-3" class="tableau-pile" data-pile-index="3"></div>
          <div id="tableau-pile-4" class="tableau-pile" data-pile-index="4"></div>
          <div id="tableau-pile-5" class="tableau-pile" data-pile-index="5"></div>
          <div id="tableau-pile-6" class="tableau-pile" data-pile-index="6"></div>
        </div>
      </div>
      <div id="game-message" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); padding: 20px 40px; border-radius: 10px; border: 2px solid #0f0; color: #0f0; font-size: 2em; font-weight: bold; text-shadow: 0 0 10px #0f0; display: none; z-index: 1001;"></div>
    </div>

    <!-- Sidebar (Donate section) -->
    <div id="sidebar">
      <h2>Support Us!</h2>
      <p>If you enjoy ad-free games from No Spin Media, consider supporting us.</p>
      <button id="donate-button" onclick="window.location.href='/sponsor.html'">Donate Now</button>
      <p style="font-size:0.8em; color:#aaa;">Your help keeps No Spin Media alive and growing.</p>
    </div>
  </div>

  <!-- How to Play Modal -->
  <div id="how-to-play-modal">
    <div class="modal-content">
      <span class="close-button">&times;</span>
      <h2>How to Play Klondike Solitaire</h2>
      <p>The goal of Klondike Solitaire is to move all cards to the four Foundation piles, building them up by suit from Ace to King.</p>
      <h3>The Layout:</h3>
      <ul>
        <li><strong>Stock Pile (top left):</strong> The remaining deck of cards. Click to draw cards to the Waste Pile.</li>
        <li><strong>Waste Pile (next to Stock):</strong> Cards drawn from the Stock pile. Only the top card is available for play.</li>
        <li><strong>Foundation Piles (top right):</strong> Four empty piles, one for each suit. Build these up from Ace to King.</li>
        <li><strong>Tableau Piles (bottom 7 columns):</strong> The main play area. Cards are dealt here face-down, with the top card face-up.</li>
      </ul>
      <h3>Moving Cards:</h3>
      <ul>
        <li><strong>Tableau to Tableau:</strong> You can move a face-up card (or a stack of face-up cards) onto another tableau pile if the receiving card is one rank higher and of an opposite color (e.g., a red 7 on a black 8).</li>
        <li><strong>Tableau to Empty Tableau:</strong> Only a King can be moved to an empty tableau pile.</li>
        <li><strong>Waste/Tableau to Foundation:</strong> You can move a single face-up card to a foundation pile if it's the same suit and one rank higher than the top card of that foundation (e.g., a 7 of Hearts on a 6 of Hearts). An Ace can start an empty foundation pile.</li>
        <li><strong>Flipping Cards:</strong> When you move a face-up card from a tableau pile, if there's a face-down card directly beneath it, that card will automatically flip face-up.</li>
      </ul>
      <h3>Winning:</h3>
      <p>You win when all 52 cards are moved to their respective Foundation piles.</p>
    </div>
  </div>

  <!-- Site-wide footer -->
  <footer style="text-align:center;color:#666;padding:10px;">
    © 2025 No Spin Media. Independent. Ad-free. Truth-focused.
  </footer>

  <script>
    // --- Game State Variables ---
    let score = 0;
    let moves = 0;
    let timer = 0;
    let gameInterval; // To hold the setInterval for the timer
    let history = []; // To store game states for undo functionality
    const MAX_HISTORY = 50; // Limit history size

    // Card data structure (example)
    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    const rankValues = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };
    const suits = ['hearts', 'diamonds', 'clubs', 'spades']; // Using full names for internal logic
    const suitSymbols = { 'hearts': '❤️', 'diamonds': '♦️', 'clubs': '♣️', 'spades': '♠️' };
    const redSuits = ['hearts', 'diamonds'];
    const blackSuits = ['clubs', 'spades'];

    let deck = [];
    let stock = [];
    let waste = [];
    let foundations = { 'hearts': [], 'diamonds': [], 'clubs': [], 'spades': [] };
    let tableau = [[], [], [], [], [], [], []]; // 7 tableau piles

    // --- DOM Elements ---
    const scoreEl = document.getElementById('score');
    const movesEl = document.getElementById('moves');
    const timeEl = document.getElementById('time');
    const stockPileEl = document.getElementById('stock-pile');
    const wastePileEl = document.getElementById('waste-pile');
    const foundationsEl = {
      hearts: document.getElementById('foundation-hearts'),
      diamonds: document.getElementById('foundation-diamonds'),
      clubs: document.getElementById('foundation-clubs'),
      spades: document.getElementById('foundation-spades')
    };
    const tableauPilesEl = Array.from({ length: 7 }, (_, i) => document.getElementById(`tableau-pile-${i}`));
    const gameMessageEl = document.getElementById('game-message');
    const howToPlayModal = document.getElementById('how-to-play-modal');
    const closeHowToPlayBtn = document.querySelector('#how-to-play-modal .close-button');
    const stockTextEl = document.getElementById('stock-text');


    let draggedCards = []; // Array of cards being dragged
    let dragSource = null; // Object { type: 'waste' | 'tableau', pileIndex: number | null, cardIndex: number | null }

    // --- Game Initialization ---
    function initializeGame() {
      console.log('initializeGame called');
      score = 0;
      moves = 0;
      timer = 0;
      updateHUD();
      clearInterval(gameInterval); // Clear any existing timer

      // Create a fresh deck
      deck = [];
      for (const suit of suits) {
        for (const rank of ranks) {
          deck.push({ rank, suit, faceUp: false });
        }
      }

      // Shuffle the deck
      shuffleDeck(deck);

      // Reset piles
      stock = [...deck]; // All cards start in stock
      waste = [];
      for (const suit in foundations) {
        foundations[suit] = [];
      }
      tableau = Array.from({ length: 7 }, () => []);

      dealInitialCards();
      console.log('Tableau after dealing:', tableau); // Debugging log
      renderGame();
      saveGameState(); // Save initial state after dealing cards
      startGameTimer(); // Start timer immediately on game load/new game
      hideGameMessage();
      console.log('Game initialized and rendered.');
    }

    function saveGameState() {
      // Deep copy relevant game state variables
      const state = {
        score: score,
        moves: moves,
        timer: timer,
        stock: JSON.parse(JSON.stringify(stock)),
        waste: JSON.parse(JSON.stringify(waste)),
        foundations: JSON.parse(JSON.stringify(foundations)),
        tableau: JSON.parse(JSON.stringify(tableau))
      };
      history.push(state);
      if (history.length > MAX_HISTORY) {
        history.shift(); // Remove oldest state
      }
    }

    function loadGameState(state) {
      score = state.score;
      moves = state.moves;
      timer = state.timer;
      stock = JSON.parse(JSON.stringify(state.stock));
      waste = JSON.parse(JSON.stringify(state.waste));
      foundations = JSON.parse(JSON.stringify(state.foundations));
      tableau = JSON.parse(JSON.stringify(state.tableau));
      updateHUD();
      renderGame();
    }

    function shuffleDeck(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
      }
    }

    function dealInitialCards() {
      console.log('dealInitialCards called');
      // Deal to tableau piles
      for (let i = 0; i < 7; i++) {
        for (let j = 0; j <= i; j++) {
          const card = stock.pop();
          if (card) {
            card.faceUp = (j === i); // Only the top card is face up
            tableau[i].push(card);
          }
        }
      }
      console.log('Stock after dealing:', stock.length); // Debugging log
    }

    // --- Rendering Functions ---
    function createCardElement(card, sourcePileType, pileIndex = null, cardIndex = null) {
      const cardEl = document.createElement('div');
      cardEl.classList.add('card');
      cardEl.dataset.rank = card.rank;
      cardEl.dataset.suit = card.suit;
      cardEl.dataset.faceUp = card.faceUp; // Store faceUp state in dataset

      // Add data attributes for drag source identification
      cardEl.dataset.sourcePileType = sourcePileType;
      if (pileIndex !== null) cardEl.dataset.sourcePileIndex = pileIndex;
      if (cardIndex !== null) cardEl.dataset.sourceCardIndex = cardIndex;

      if (redSuits.includes(card.suit)) {
        cardEl.classList.add('red');
      }

      if (card.faceUp) {
        cardEl.innerHTML = `
          <div class="card-rank top-left">${card.rank}</div>
          <div class="card-suit">${suitSymbols[card.suit]}</div>
          <div class="card-rank bottom-right">${card.rank}</div>
        `;
        cardEl.setAttribute('draggable', 'true'); // Make face-up cards draggable
      } else {
        cardEl.classList.add('card-back');
        cardEl.setAttribute('draggable', 'false'); // Face-down cards are not draggable
      }
      return cardEl;
    }

    function renderGame() {
      console.log('renderGame called');
      // Clear all existing cards from DOM
      stockPileEl.innerHTML = '';
      wastePileEl.innerHTML = '';
      for (const suit in foundationsEl) {
        foundationsEl[suit].innerHTML = `<span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3em; color: #ADD8E6;">${suitSymbols[suit]}</span>`;
      }
      tableauPilesEl.forEach(pileEl => pileEl.innerHTML = '');

      // Render Stock pile
      if (stock.length > 0) {
        const stockCardEl = createCardElement({ rank: '', suit: '', faceUp: false }, 'stock');
        stockPileEl.appendChild(stockCardEl);
        // Ensure the text element exists before trying to update its innerHTML
        if (stockTextEl) {
          stockTextEl.innerHTML = `Stock<br>Click to Draw`;
        } else {
          stockPileEl.innerHTML += `<span id="stock-text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">Stock<br>Click to Draw</span>`;
        }
      } else {
        stockPileEl.innerHTML = `<span id="stock-text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">Empty<br>Click to Reload</span>`;
      }

      // Render Waste pile
      if (waste.length > 0) {
        // Render all waste cards for visual stack, but only last one is interactive
        waste.forEach((card, index) => {
          const wasteCardEl = createCardElement(card, 'waste', null, index);
          // Position waste cards slightly offset for stacking effect
          // Only show the top 3 cards in the waste pile, with the top one fully visible
          if (index >= waste.length - 3) { // Show last 3 cards
            wasteCardEl.style.position = 'absolute'; // Keep absolute for manual positioning
            wasteCardEl.style.left = `${(index - (waste.length - 1)) * 15 + (waste.length > 1 ? 75 : 0)}px`; // Adjust offset for visibility
            wasteCardEl.style.zIndex = index;
            wastePileEl.appendChild(wasteCardEl);
          }
        });
        // Ensure the empty waste pile placeholder is hidden when cards are present
        wastePileEl.querySelector('span')?.remove();
      } else {
        wastePileEl.innerHTML = `<span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">Waste</span>`;
      }


      // Render Foundations
      for (const suit in foundations) {
        if (foundations[suit].length > 0) {
          const topCard = foundations[suit][foundations[suit].length - 1];
          const cardEl = createCardElement(topCard, 'foundation', suit);
          foundationsEl[suit].appendChild(cardEl);
        }
      }

      // Render Tableau piles
      tableau.forEach((pile, pileIndex) => {
        const pileEl = tableauPilesEl[pileIndex];
        pile.forEach((card, cardIndex) => {
          const cardEl = createCardElement(card, 'tableau', pileIndex, cardIndex);
          // Position cards for stacking effect - REDUCED OFFSET
          cardEl.style.top = `${cardIndex * 15}px`; // Adjusted from 20px to 15px
          cardEl.style.zIndex = cardIndex; // Ensure proper stacking order
          pileEl.appendChild(cardEl);
        });
      });

      addCardEventListeners(); // Re-add event listeners after re-rendering
      console.log('renderGame completed.');
    }

    // --- HUD Update ---
    function updateHUD() {
      scoreEl.innerText = score;
      movesEl.innerText = moves;
      const minutes = Math.floor(timer / 60);
      const seconds = timer % 60;
      timeEl.innerText = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }

    // --- Game Timer ---
    function startGameTimer() {
      gameInterval = setInterval(() => {
        timer++;
        updateHUD();
        checkWinCondition(); // Check win condition periodically
      }, 1000);
    }

    // --- Game Logic and Validation ---
    function getTopCard(pile) {
      return pile.length > 0 ? pile[pile.length - 1] : null;
    }

    function isMoveValid(cardsToMove, targetPileType, targetPile) {
      if (cardsToMove.length === 0) return false;

      const firstCardToMove = cardsToMove[0];
      const targetTopCard = getTopCard(targetPile);

      // Rule: Must be face-up
      if (!firstCardToMove.faceUp) return false;

      if (targetPileType === 'tableau') {
        // Tableau rules: alternating color, descending rank
        if (!targetTopCard) { // Empty tableau pile
          return firstCardToMove.rank === 'K'; // Only King can start an empty tableau pile
        }
        const targetRankValue = rankValues[targetTopCard.rank];
        const movingRankValue = rankValues[firstCardToMove.rank];

        const targetIsRed = redSuits.includes(targetTopCard.suit);
        const movingIsRed = redSuits.includes(firstCardToMove.suit);

        return (movingRankValue === targetRankValue - 1) && (targetIsRed !== movingIsRed);
      } else if (targetPileType === 'foundation') {
        // Foundation rules: same suit, ascending rank
        if (!targetTopCard) { // Empty foundation pile
          return firstCardToMove.rank === 'A' && cardsToMove.length === 1; // Only Ace can start an empty foundation
        }
        const targetRankValue = rankValues[targetTopCard.rank];
        const movingRankValue = rankValues[firstCardToMove.rank];

        return (firstCardToMove.suit === targetTopCard.suit) && (movingRankValue === targetRankValue + 1) && cardsToMove.length === 1; // Only single cards to foundation
      }
      return false;
    }

    function performMove(cards, source, destinationType, destinationIndex) {
      saveGameState(); // Save state before performing the move

      // Remove cards from source
      if (source.type === 'waste') {
        waste.pop(); // Only the top card from waste
      } else if (source.type === 'tableau') {
        tableau[source.pileIndex].splice(source.cardIndex); // Remove from cardIndex to end
        // Flip the new top card in the source tableau pile if it's face-down
        const sourcePile = tableau[source.pileIndex];
        if (sourcePile.length > 0 && !getTopCard(sourcePile).faceUp) {
          getTopCard(sourcePile).faceUp = true;
          score += 5; // Score for flipping a card
        }
      }

      // Add cards to destination
      if (destinationType === 'tableau') {
        tableau[destinationIndex].push(...cards);
        score += (source.type === 'waste' ? 5 : 0); // Score for moving from waste to tableau
      } else if (destinationType === 'foundation') {
        foundations[destinationIndex].push(...cards);
        score += 10; // Score for moving to foundation
      }
      moves++;
      renderGame();
      updateHUD();
      checkWinCondition();
    }

    function checkWinCondition() {
      const allFoundationsFull = Object.values(foundations).every(pile => pile.length === 13);
      if (allFoundationsFull) {
        displayGameMessage("You Win! 🎉");
        clearInterval(gameInterval);
      }
    }

    function displayGameMessage(message) {
      gameMessageEl.innerText = message;
      gameMessageEl.style.display = 'block';
    }

    function hideGameMessage() {
      gameMessageEl.style.display = 'none';
    }

    // --- Drag and Drop Event Handlers ---
    function handleDragStart(e) {
      const cardEl = e.target;
      if (!cardEl.classList.contains('card') || cardEl.classList.contains('card-back')) {
        e.preventDefault(); // Only draggable if it's a face-up card
        return;
      }

      cardEl.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';

      const sourcePileType = cardEl.dataset.sourcePileType;
      const sourcePileIndex = cardEl.dataset.sourcePileIndex ? parseInt(cardEl.dataset.sourcePileIndex) : null;
      const sourceCardIndex = cardEl.dataset.sourceCardIndex ? parseInt(cardEl.dataset.sourceCardIndex) : null;

      dragSource = { type: sourcePileType, pileIndex: sourcePileIndex, cardIndex: sourceCardIndex };

      draggedCards = [];
      if (sourcePileType === 'tableau') {
        // Get the stack of cards from the tableau
        draggedCards = tableau[sourcePileIndex].slice(sourceCardIndex);
      } else if (sourcePileType === 'waste') {
        draggedCards = [waste[waste.length - 1]]; // Only the top card from waste
      }

      // Set data for dataTransfer (useful for debugging, not strictly for visual drag in this setup)
      e.dataTransfer.setData('text/plain', JSON.stringify({
        cards: draggedCards.map(c => ({ rank: c.rank, suit: c.suit })),
        source: dragSource
      }));
    }

    function handleDragOver(e) {
      e.preventDefault(); // Allow drop
      e.dataTransfer.dropEffect = 'move';

      // Highlight potential drop targets
      const targetEl = e.target.closest('.pile-container, .tableau-pile');
      if (targetEl) {
        const targetPileType = targetEl.id.includes('foundation') ? 'foundation' : 'tableau';
        let targetPile = [];
        let targetIndex;

        if (targetPileType === 'foundation') {
          targetIndex = targetEl.dataset.suit;
          targetPile = foundations[targetIndex];
        } else { // tableau
          targetIndex = parseInt(targetEl.dataset.pileIndex);
          targetPile = tableau[targetIndex];
        }

        if (isMoveValid(draggedCards, targetPileType, targetPile)) {
          targetEl.classList.add('drag-over');
        } else {
          targetEl.classList.remove('drag-over');
        }
      }
    }

    function handleDragLeave(e) {
      const targetEl = e.target.closest('.pile-container, .tableau-pile');
      if (targetEl) {
        targetEl.classList.remove('drag-over');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      const targetEl = e.target.closest('.pile-container, .tableau-pile');
      if (!targetEl) {
        // Dropped outside a valid target, clean up
        document.querySelectorAll('.card.dragging').forEach(card => card.classList.remove('dragging'));
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        draggedCards = [];
        dragSource = null;
        return;
      }

      targetEl.classList.remove('drag-over');

      const destinationType = targetEl.id.includes('foundation') ? 'foundation' : 'tableau';
      let destinationIndex;
      let destinationPile;

      if (destinationType === 'foundation') {
        destinationIndex = targetEl.dataset.suit;
        destinationPile = foundations[destinationIndex];
      } else { // tableau
        destinationIndex = parseInt(targetEl.dataset.pileIndex);
        destinationPile = tableau[destinationIndex];
      }

      if (isMoveValid(draggedCards, destinationType, destinationPile)) {
        performMove(draggedCards, dragSource, destinationType, destinationIndex);
      } else {
        console.log('Invalid move!');
      }

      // Clean up drag state
      document.querySelectorAll('.card.dragging').forEach(card => card.classList.remove('dragging'));
      draggedCards = [];
      dragSource = null;
    }

    function handleDragEnd(e) {
      // Clean up any lingering dragging classes if drop didn't happen on a valid target
      document.querySelectorAll('.card.dragging').forEach(card => card.classList.remove('dragging'));
      document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
      draggedCards = [];
      dragSource = null;
    }

    // --- Click-to-Move Logic ---
    function handleClickCard(e) {
      const clickedCardEl = e.target.closest('.card');
      if (!clickedCardEl || clickedCardEl.classList.contains('card-back')) return; // Only interact with face-up cards

      const sourcePileType = clickedCardEl.dataset.sourcePileType;
      const sourcePileIndex = clickedCardEl.dataset.sourcePileIndex ? parseInt(clickedCardEl.dataset.sourcePileIndex) : null;
      const sourceCardIndex = clickedCardEl.dataset.sourceCardIndex ? parseInt(clickedCardEl.dataset.sourceCardIndex) : null;

      let cardToMove;
      let currentSourcePile;

      if (sourcePileType === 'waste') {
        if (waste.length === 0 || sourceCardIndex !== waste.length - 1) return; // Only top waste card is clickable
        cardToMove = waste[sourceCardIndex];
        currentSourcePile = waste;
      } else if (sourcePileType === 'tableau') {
        currentSourcePile = tableau[sourcePileIndex];
        if (sourceCardIndex !== currentSourcePile.length - 1) return; // Only top tableau card is clickable for auto-move
        cardToMove = currentSourcePile[sourceCardIndex];
      } else {
        return; // Foundations are not sources for click-to-move
      }

      // Attempt to move to foundations first
      for (const suit in foundations) {
        const targetPile = foundations[suit];
        if (isMoveValid([cardToMove], 'foundation', targetPile)) {
          performMove([cardToMove], { type: sourcePileType, pileIndex: sourcePileIndex, cardIndex: sourceCardIndex }, 'foundation', suit);
          return;
        }
      }

      // If not to foundation, attempt to move to tableau piles
      for (let i = 0; i < 7; i++) {
        const targetPile = tableau[i];
        // Prevent moving a card to its own pile (unless it's the only valid move for a stack, which is not the case for single click-move)
        if (sourcePileType === 'tableau' && sourcePileIndex === i) continue;

        if (isMoveValid([cardToMove], 'tableau', targetPile)) {
          performMove([cardToMove], { type: sourcePileType, pileIndex: sourcePileIndex, cardIndex: sourceCardIndex }, 'tableau', i);
          return;
        }
      }
      console.log('No valid auto-move destination found for this card.');
    }


    // --- Event Listeners Setup ---
    function addCardEventListeners() {
      document.querySelectorAll('.card').forEach(cardEl => {
        // Remove existing listeners to prevent duplicates on re-render
        cardEl.removeEventListener('dragstart', handleDragStart);
        cardEl.removeEventListener('click', handleClickCard);

        if (cardEl.dataset.faceUp === 'true') { // Only face-up cards are interactive
          cardEl.addEventListener('dragstart', handleDragStart);
          cardEl.addEventListener('click', handleClickCard);
        }
      });

      // Add dragover/dragleave/drop listeners to all potential drop targets
      document.querySelectorAll('.pile-container, .tableau-pile').forEach(pileEl => {
        pileEl.removeEventListener('dragover', handleDragOver);
        pileEl.removeEventListener('dragleave', handleDragLeave);
        pileEl.removeEventListener('drop', handleDrop);

        pileEl.addEventListener('dragover', handleDragOver);
        pileEl.addEventListener('dragleave', handleDragLeave);
        pileEl.addEventListener('drop', handleDrop);
      });

      // Add dragend listener to the document to clean up if drop happens outside a valid target
      document.removeEventListener('dragend', handleDragEnd);
      document.addEventListener('dragend', handleDragEnd);
    }

    // --- Button Event Handlers ---
    function handleNewGame() {
      console.log('New Game clicked!');
      history = []; // Clear history for new game
      initializeGame();
      // saveGameState() and startGameTimer() are now called within initializeGame()
    }

    function handleUndo() {
      console.log('Undo clicked!');
      if (history.length > 1) { // Need at least two states to undo (current and previous)
        history.pop(); // Remove current state
        loadGameState(history[history.length - 1]); // Load previous state
        clearInterval(gameInterval); // Pause timer during undo
        startGameTimer(); // Restart timer
      } else {
        console.log('No more moves to undo.');
      }
    }

    function handleHint() {
      console.log('Hint clicked!');
      // TODO: Implement hint logic here
    }

    function showHowToPlay() {
      howToPlayModal.style.display = 'flex'; // Use flex to center content
    }

    function hideHowToPlay() {
      howToPlayModal.style.display = 'none';
    }

    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('newGameBtn').addEventListener('click', handleNewGame);
      document.getElementById('undoBtn').addEventListener('click', handleUndo);
      document.getElementById('hintBtn').addEventListener('click', handleHint);
      document.getElementById('howToPlayBtn').addEventListener('click', showHowToPlay);
      closeHowToPlayBtn.addEventListener('click', hideHowToPlay);
      window.addEventListener('click', (event) => { // Close modal if clicked outside
        if (event.target == howToPlayModal) {
          hideHowToPlay();
        }
      });

      // Share and Copy Link buttons
      document.getElementById('shareBtn').onclick = () => {
        if (navigator.share) {
          navigator.share({
            title: "Klondike Solitaire - No Spin Media",
            url: window.location.href
          }).catch((error) => console.error('Error sharing:', error));
        } else {
          navigator.clipboard.writeText(window.location.href)
            .then(() => console.log("Link copied to clipboard!"))
            .catch((error) => console.error('Failed to copy link:', error));
        }
      };
      document.getElementById('copyBtn').onclick = () => {
        navigator.clipboard.writeText(window.location.href)
          .then(() => console.log("Link copied to clipboard!"))
          .catch((error) => console.error('Failed to copy link:', error));
      };


      // Stock pile click (deal from stock)
      stockPileEl.addEventListener('click', () => {
        if (stock.length > 0) {
          saveGameState(); // Save state before dealing
          const card = stock.pop();
          card.faceUp = true;
          waste.push(card);
          moves++;
          score -= 1; // Penalty for using stock
          renderGame();
          updateHUD();
        } else if (waste.length > 0) {
          saveGameState(); // Save state before redealing
          // If stock is empty, move waste back to stock (redeal)
          stock = waste.reverse().map(c => ({ ...c, faceUp: false })); // Flip cards back down
          waste = [];
          moves++;
          score -= 20; // Penalty for redealing
          renderGame();
          updateHUD();
        }
      });

      // Initialize the game when the page loads
      initializeGame();
    });

  </script>
</body>
</html>
