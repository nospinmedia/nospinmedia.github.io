<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sudoku - No Spin Media</title>
  <link rel="stylesheet" href="/style.css">
  <!-- Open Graph and Twitter Card Meta Tags -->
  <meta property="og:title" content="Play Sudoku 🧩 - No Spin Media">
  <meta property="og:description" content="Free ad-free Sudoku game! Easy, Medium, and Hard levels. Play now!">
  <meta property="og:image" content="https://nospin.media/images/sudoku-preview.png">
  <meta property="og:url" content="https://nospin.media/games/puzzles/sudoku/index.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Play Sudoku 🧩 - No Spin Media">
  <meta name="twitter:description" content="Free ad-free Sudoku game! Easy, Medium, and Hard levels.">
  <meta name="twitter:image" content="https://nospin.media/images/sudoku-preview.png">
  <style>
    /* Global box-sizing for consistent layout */
    * {
      box-sizing: border-box;
    }

    /* Global body styles for the game theme - same as chess */
    body {
      background: #222831; /* Deep charcoal for a calm background */
      color: #fff;
      margin: 0;
      font-family: 'Inter', Arial, sans-serif; /* Using Inter for a modern look */
      display: flex;
      flex-direction: column;
      min-height: 100vh; /* Ensure footer stays at bottom */
    }

    /* New wrapper for header and game content to control mobile order */
    #main-content-wrapper {
        display: flex;
        flex-direction: column; /* Default: header on top */
        flex-grow: 1; /* Allow it to grow and push footer down */
    }

    /* Site header styling (adjust if needed, but usually handled by /header.html's CSS) */
    #site-header {
        width: 100%; /* Ensure it takes full width */
    }

    /* Main game container layout - same as chess */
    #game-container {
      display: flex;
      justify-content: center;
      padding: 20px;
      gap: 30px;
      flex-wrap: wrap; /* Allows wrapping on smaller screens */
      flex-grow: 1; /* Allows container to grow and push footer down */
    }

    /* Game box styling (main game area) - same as chess */
    #game-box {
      border: 2px solid #74B9FF; /* Muted blue border */
      box-shadow: 0 0 20px #74B9FF; /* Muted blue glow */
      padding: 20px 20px 25px 20px; /* Adjusted padding-bottom */
      border-radius: 12px; /* More rounded corners */
      background: #222831; /* Match body background */
      position: relative;
      flex-grow: 1;
      max-width: 380px; /* Adjusted max-width for desktop to fit smaller board */
      width: 100%; /* Ensure it takes full width within max-width */
      min-width: 320px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start; /* Changed to flex-start */
      margin-top: 20px; /* Added margin-top to push it down */
    }

    /* Consistent spacing between major sections within game-box */
    #game-box > * {
      margin-bottom: 15px;
    }
    /* Specific overrides for no gap */
    #sudoku-board {
      margin-bottom: 0; /* Remove margin below board */
    }
    #number-pad {
      margin-top: 0; /* Ensure no top margin for number pad */
      margin-bottom: 0; /* Ensure no bottom margin for number pad */
    }


    /* Game header styling - same as chess */
    #game-header {
      color: #74B9FF;
      text-align: center;
      font-size: 2.2em;
      text-shadow: 0 0 10px #74B9FF;
      position: relative;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(116, 185, 255, 0.3);
    }

    #game-version {
      position: absolute;
      top: 5px;
      right: 15px;
      color: #74B9FF;
      font-size: 0.5em; /* Made version font size much smaller */
      opacity: 0.7;
    }

    /* Game info (messages) */
    #game-info {
      text-align: center;
      color: #74B9FF;
      font-weight: bold;
      font-size: 1.1em;
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      gap: 10px;
      min-height: 30px; /* Ensure a consistent height to prevent shifts */
    }
    #game-info span {
      padding: 5px 10px;
      background: rgba(116, 185, 255, 0.1);
      border-radius: 5px;
    }

    /* Game controls/buttons */
    .game-controls {
      text-align: center;
      display: flex;
      flex-wrap: wrap; /* Allows wrapping */
      gap: 10px;
      max-width: 100%; /* Ensure it respects parent width */
      justify-content: center; /* Center items within the flex container */
    }

    .game-controls button,
    .game-controls select {
      padding: 5px 8px; /* Further reduced padding to make buttons less tall */
      margin: 0; /* Remove individual margins as gap handles spacing */
      background: #60A3D9;
      color: #000;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 0.8em; /* Slightly smaller font for buttons */
      box-shadow: 0 0 10px rgba(96, 163, 217, 0.5);
      transition: all 0.2s ease-in-out;
      flex-grow: 1; /* Allow items to grow */
      flex-shrink: 1; /* Allow items to shrink */
      min-width: 80px; /* Minimum width to prevent squishing */
    }

    /* Specific widths for top row buttons to ensure 3 fit */
    .game-controls #newGameBtn,
    .game-controls #difficultySelect,
    .game-controls #solveBtn {
        flex-basis: calc(33.33% - 10px); /* Roughly 1/3 width each, accounting for gap */
        max-width: calc(33.33% - 10px);
    }

    /* Specific widths for second row buttons to ensure 2 fit */
    .game-controls #shareBtn,
    .game-controls #copyBtn {
        flex-basis: calc(50% - 10px); /* Roughly 1/2 width each, accounting for gap */
        max-width: calc(50% - 10px);
    }

    .game-controls button:hover,
    .game-controls select:hover {
      background: #7ABCEF;
      box-shadow: 0 0 15px rgba(122, 188, 239, 0.8);
      transform: translateY(-2px);
    }

    .game-controls button:active,
    .game-controls select:active {
      transform: translateY(0);
      box-shadow: 0 0 5px rgba(96, 163, 217, 0.3);
    }

    /* Difficulty dropdown */
    .game-controls select {
        border: 1px solid #60A3D9;
        background-color: #2E4057;
        color: #fff;
        font-size: 0.8em; /* Match button font size */
        outline: none;
    }


    /* Sidebar styling (Donate section) - same as chess */
    #sidebar {
      background: #222831;
      border: 2px solid #74B9FF;
      box-shadow: 0 0 15px #74B9FF;
      padding: 20px;
      border-radius: 8px;
      max-width: 280px;
      height: fit-content;
      text-align: center;
      margin-top: 15px;
      flex-shrink: 0; /* Prevent sidebar from shrinking */
    }

    #sidebar h2 {
      color: #74B9FF;
      text-align: center;
      margin-bottom: 15px;
    }

    #donate-button {
      background: #ffd700;
      color: #000;
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin: 15px auto 10px;
      display: block;
      transition: all 0.2s ease-in-out;
    }

    #donate-button:hover {
      background: #ffe033;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
      transform: translateY(-2px);
    }

    #donate-button:active {
      transform: translateY(0);
      box-shadow: 0 0 5px rgba(96, 163, 217, 0.3);
    }

    #sidebar p {
      font-size: 0.9em;
      color: #aaa;
      line-height: 1.4;
    }

    /* Footer styling - same as chess */
    footer {
      text-align: center;
      color: #666;
      padding: 15px;
      font-size: 0.9em;
      margin-top: auto;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* --- Sudoku Board Specific Layout --- */
    #sudoku-board {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr); /* Use 1fr for rows too */
      width: 100%; /* Make board take 100% of parent's width */
      aspect-ratio: 1 / 1; /* Re-added aspect ratio for desktop */
      border: 4px solid #74B9FF;
      box-shadow: 0 0 25px rgba(116, 185, 255, 0.5);
      border-radius: 8px;
      overflow: hidden;
      flex-shrink: 0;
      /* flex-grow: 1; Removed flex-grow to prevent stretching */
      max-width: 340px; /* Adjusted max width for desktop to fit smaller board */
      height: 340px; /* Explicit height for desktop to ensure 9 rows fit */
    }

    .sudoku-cell {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2em; /* Adjusted font size for desktop */
      font-weight: bold;
      cursor: pointer;
      border: 1px solid #333;
      background-color: #AEC6CF;
      color: #000;
      transition: background-color 0.2s ease-in-out;
      position: relative; /* For pencil marks positioning */
      height: 100%; /* Ensure cell takes full height of its grid row */
      width: 100%; /* Ensure cell takes full width of its grid column */
      overflow: hidden; /* Clip content if it overflows */
    }

    /* Pencil marks grid inside cell */
    .sudoku-cell .pencil-marks {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        width: 100%;
        height: 100%;
        font-size: 0.4em; /* Further reduced font size for pencil marks */
        color: #fff; /* Changed to white for better visibility */
        font-weight: normal;
        gap: 0; /* Reduced gap to 0 */
        padding: 0; /* Reduced padding to 0 */
    }
    .sudoku-cell .pencil-marks div {
        display: flex;
        justify-content: center;
        align-items: center;
        color: #fff; /* Default pencil mark color */
    }
    /* Highlighted pencil mark */
    .sudoku-cell .pencil-marks div.highlighted-pencil-mark {
        background-color: #87CEEB; /* Light blue background for highlighted pencil mark */
        color: #000; /* Black text for contrast */
    }


    /* Darker background for 3x3 blocks */
    .sudoku-cell:nth-child(3n):not(:last-child) {
        border-right: 2px solid #555;
    }
    .sudoku-cell:nth-child(9n) {
        border-right: 1px solid #333; /* Reset for last column */
    }
    .sudoku-cell:nth-child(n) {
        border-bottom: 1px solid #333;
    }
    .sudoku-cell:nth-child(n + 19):nth-child(-n + 27),
    .sudoku-cell:nth-child(n + 46):nth-child(-n + 54) {
        border-bottom: 2px solid #555;
    }
    /* Specific styling for 3x3 block borders */
    .sudoku-cell:nth-child(3n+1) { border-left: 1px solid #333; }
    .sudoku-cell:nth-child(9n+1) { border-left: 1px solid #333; }

    .sudoku-cell.fixed {
      background-color: #4A6572;
      color: #F8F8F8;
      cursor: default;
    }

    .sudoku-cell.selected {
      background-color: #4682B4;
      box-shadow: inset 0 0 10px #4682B4;
    }

    .sudoku-cell.invalid {
      background-color: #FF6347;
      color: #fff;
    }

    .sudoku-cell.highlight-same-value {
        background-color: #87CEEB;
    }

    .sudoku-cell.highlight-group {
        background-color: rgba(116, 185, 255, 0.3);
    }

    /* New: Highlight for selected number from pad */
    .sudoku-cell.highlight-number-selection {
        background-color: #87CEEB; /* Light blue highlight */
        color: #000; /* Black text for contrast */
        border: 1px solid #4682B4; /* Add border for grid-line effect */
        box-shadow: inset 0 0 5px #4682B4; /* Add subtle shadow for grid-line effect */
    }
    /* Dim unselected cells when a number is highlighted */
    .sudoku-cell:not(.highlight-number-selection):not(.fixed):not(.selected):not(.invalid):not(.highlight-group) {
        opacity: 0.7; /* Dim unselected cells */
    }

    /* New: Unsolvable error state */
    .sudoku-cell.unsolvable-error {
        border: 3px solid #FF0000; /* Thicker red border */
        box-shadow: 0 0 15px #FF0000; /* Red glow */
        animation: pulse-error 1s infinite alternate;
    }
    @keyframes pulse-error {
        from { box-shadow: 0 0 15px #FF0000; }
        to { box-shadow: 0 0 25px #FF0000; }
    }


    /* Number input pad */
    #number-pad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      padding: 10px;
      border-radius: 8px;
      background: #2E4057;
      flex-shrink: 0; /* Ensure it doesn't shrink */
    }

    #number-pad button {
      padding: 8px; /* Reduced padding for number buttons */
      background: #60A3D9;
      color: #000;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      font-size: 0.8em; /* Adjusted font size for desktop */
      cursor: pointer;
      box-shadow: 0 0 8px rgba(96, 163, 217, 0.5);
      transition: all 0.2s ease-in-out;
    }

    #number-pad button:hover {
      background: #7ABCEF;
      box-shadow: 0 0 12px rgba(122, 188, 239, 0.8);
      transform: translateY(-2px);
    }

    #number-pad button:active {
      transform: translateY(0);
      box-shadow: 0 0 4px rgba(96, 163, 217, 0.3);
    }

    /* Adjust grid for Clear and Pencil Mode to be side-by-side */
    #number-pad .bottom-row-buttons {
        grid-column: span 3; /* Container for these two buttons spans all 3 columns */
        display: flex;
        gap: 10px;
        justify-content: space-between; /* Distribute space evenly */
    }

    #number-pad button.clear-button,
    #number-pad button.pencil-mode-button,
    #number-pad button.auto-pencil-button { /* Added auto-pencil-button */
      flex: 1 1 calc(33.33% - 7px); /* Each takes roughly 1/3 space minus gap for 3 buttons */
      padding: 8px 5px; /* Reduced padding for 3 buttons */
      background: #FF6347; /* Default color for Clear */
      color: #fff;
      font-size: 0.75em; /* Slightly smaller font for 3 buttons */
    }
    #number-pad button.clear-button {
        background: #FF6347; /* Red for Clear */
    }
    #number-pad button.clear-button:hover {
        background: #FF7F50;
    }
    #number-pad button.pencil-mode-button {
        background: #60A3D9; /* Blue for Pencil Mode */
    }
    #number-pad button.pencil-mode-button:hover {
        background: #7ABCEF;
    }
    #number-pad button.auto-pencil-button { /* Style for Auto Pencil button */
        background: #28a745; /* Green for Auto Pencil */
    }
    #number-pad button.auto-pencil-button:hover {
        background: #218838;
    }

    #number-pad button.pencil-mode-button.active-mode {
        background: #FFD700; /* Gold for active pencil mode */
        color: #000;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
    }
    #number-pad button.auto-pencil-button.active-mode { /* Style for active Auto Pencil button */
        background: #FFD700; /* Gold for active auto pencil mode */
        color: #000;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
    }


    /* Game message box (for all messages) - same as chess */
    #game-message {
      position: relative;
      margin: 10px auto;
      background: rgba(0,0,0,0.8);
      padding: 10px 20px;
      border-radius: 8px;
      border: 2px solid #74B9FF;
      color: #74B9FF;
      font-size: 1.5em;
      font-weight: bold;
      text-shadow: 0 0 5px #74B9FF;
      display: none;
      text-align: center;
      width: fit-content;
      max-width: 80%;
      z-index: 1001;
    }

    /* Style for game over message - same as chess */
    #game-message.game-over-style {
      color: #FFD700;
      font-size: 2.5em;
      text-shadow: 0 0 20px #FFD700;
      padding: 20px 30px;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      /* Reverse order of header and game container on mobile */
      #main-content-wrapper {
          flex-direction: column-reverse;
      }

      #game-container {
        flex-direction: column;
        align-items: center;
        padding: 10px;
      }
      #game-box {
        width: 100%;
        max-width: none; /* Allow full width on mobile */
        padding: 2vw 2vw 2vw 2vw; /* Adjusted responsive padding on mobile */
        margin-top: 2vw; /* Responsive margin-top for mobile */
      }
      /* Responsive spacing between major sections within game-box */
      #game-box > * {
        margin-bottom: 1.5vw;
      }
      #sidebar {
        width: 100%;
        max-width: none;
        margin-top: 20px;
      }
      #sudoku-board {
        width: 90vw; /* Adjusted to 90vw for more space */
        height: 90vw; /* Explicit height for mobile (90vw / 9 * 9) */
        max-width: none; /* Removed fixed max-width */
        max-height: none; /* Removed fixed max-height */
        min-height: unset; /* Remove min-height for mobile */
        aspect-ratio: 1 / 1; /* Keep aspect ratio for mobile */
      }
      .sudoku-cell {
        width: calc(90vw / 9); /* Ensures 9 cells fit within 90vw board */
        height: calc(90vw / 9); /* Ensure cell takes full height of its grid row */
        font-size: 4.5vw; /* Adjusted font size responsively */
      }
      .sudoku-cell .pencil-marks {
          font-size: 1.2vw; /* Further smaller font for pencil marks on mobile */
          padding: 0; /* Reduced padding to 0 */
          gap: 0; /* Reduced gap to 0 */
      }
      #number-pad {
        padding: 1.5vw; /* Responsive padding on mobile */
        grid-template-columns: repeat(3, 1fr); /* 3 columns for numbers */
      }
      #number-pad button {
        font-size: 3vw; /* Responsive font size for buttons */
        padding: 1.2vw; /* Responsive padding */
      }
      #number-pad .bottom-row-buttons {
          grid-column: span 3; /* On mobile, the container spans 3 columns */
          flex-direction: row; /* Ensure they stay side by side */
          justify-content: space-around;
      }
      #number-pad button.clear-button,
      #number-pad button.pencil-mode-button,
      #number-pad button.auto-pencil-button { /* Added auto-pencil-button */
        flex: 1 1 auto; /* Allow them to size automatically within the flex container */
        font-size: 2.8vw; /* Match other buttons */
        padding: 1.2vw 0.8vw; /* Match other buttons, slightly less horizontal padding */
      }
      .game-controls {
        gap: 1.5vw; /* Responsive gap */
      }
      .game-controls button {
        font-size: 2.5vw; /* Responsive font size */
        padding: 0.8vw 1.5vw; /* Responsive padding */
      }
      .game-controls select {
        font-size: 2.5vw; /* Responsive font size */
        padding: 0.8vw 1.5vw;
      }
      #game-header {
        font-size: 5vw; /* Responsive header font size */
      }
      #game-version {
        font-size: 2vw;
        right: 3vw;
        top: 1.5vw;
      }
      #game-info {
        font-size: 2.8vw; /* Responsive info font size */
        gap: 2vw;
      }
      #game-info span {
        padding: 1vw 2vw;
      }
      #game-message {
        font-size: 3.5vw; /* Responsive messages font size */
        padding: 2vw 4vw;
        margin: 2vw auto;
      }
      #game-message.game-over-style {
        font-size: 5vw; /* Responsive game over message font size */
        padding: 3vw 5vw;
      }
    }
  </style>
</head>
<body>

  <div id="main-content-wrapper">
    <!-- Site-wide header (fetched dynamically) -->
    <div id="site-header"></div> 
    <div id="game-container">
      <div id="game-box">
        <div id="game-header">Sudoku 🧩 <span id="game-version">v2.261</span></div>
        <div id="game-info">
          <span>Difficulty: <span id="current-difficulty">Medium</span></span>
          <span id="game-status">Ready</span>
        </div>

        <div class="game-controls">
          <button id="newGameBtn">✨ New Game</button>
          <select id="difficultySelect">
              <option value="easy">Easy</option>
              <option value="medium" selected>Medium</option>
              <option value="hard">Hard</option>
          </select>
          <button id="solveBtn">💡 Solve</button>
          <button id="shareBtn">🔗 Share with Friends</button>
          <button id="copyBtn">📋 Copy Link</button>
        </div>

        <!-- Game message box for notifications -->
        <div id="game-message"></div>

        <div id="sudoku-board">
          <!-- Sudoku cells will be dynamically generated here -->
        </div>

        <div id="number-pad">
          <button data-value="1">1</button>
          <button data-value="2">2</button>
          <button data-value="3">3</button>
          <button data-value="4">4</button>
          <button data-value="5">5</button>
          <button data-value="6">6</button>
          <button data-value="7">7</button>
          <button data-value="8">8</button>
          <button data-value="9">9</button>
          <div class="bottom-row-buttons">
              <button data-value="clear" class="clear-button">Clear</button>
              <button id="autoPencilBtn" class="auto-pencil-button">📝 Auto Pencil OFF</button>
              <button id="pencilModeBtn" class="pencil-mode-button">✏️ Pencil Mode OFF</button>
          </div>
        </div>
      </div>

      <!-- Sidebar (Donate section) -->
      <div id="sidebar">
        <h2>Support Us!</h2>
        <p>If you enjoy ad-free games from No Spin Media, consider supporting us.</p>
        <button id="donate-button" onclick="window.location.href='/sponsor.html'">Donate Now</button>
        <p style="font-size:0.8em; color:#aaa;">Your help keeps No Spin Media alive and growing.</p>
      </div>
    </div>
  </div>

  <!-- Site-wide footer -->
  <footer>
    © 2025 No Spin Media. Independent. Ad-free. Truth-focused.
  </footer>

  <script>
    // Fetch header content and inject it into the correct div
    fetch(window.location.origin + '/header.html')
      .then(r => r.text())
      .then(h => document.getElementById('site-header').innerHTML = h)
      .catch(e => console.error('Error fetching header:', e));

    // --- Game State Variables ---
    let board = Array(9).fill(0).map(() => Array(9).fill(0)); // Current state of the board
    let solution = Array(9).fill(0).map(() => Array(9).fill(0)); // Solved board
    let initialBoard = Array(9).fill(0).map(() => Array(9).fill(0)); // Initial puzzle with fixed numbers
    let selectedCell = null; // { row, col } of the currently selected cell
    let difficulty = 'medium'; // 'easy', 'medium', 'hard'
    let messageTimeoutId = null; // To manage the hide timeout for temporary messages
    let gameEnded = false; // Flag to indicate if the game has ended
    let pencilMode = false; // Manual pencil mode state
    let autoPencilMode = false; // New: Auto pencil mode state
    // New: Store user's manual pencil marks separately
    let userPencilMarks = Array(9).fill(0).map(() => Array(9).fill(0).map(() => new Set()));
    let selectedNumberFromPad = null; // New: Stores the number selected from the pad for highlighting


    // --- DOM Elements ---
    const sudokuBoardEl = document.getElementById('sudoku-board');
    const numberPadEl = document.getElementById('number-pad');
    const newGameBtn = document.getElementById('newGameBtn');
    const solveBtn = document.getElementById('solveBtn');
    const difficultySelect = document.getElementById('difficultySelect');
    const gameMessageEl = document.getElementById('game-message');
    const currentDifficultyEl = document.getElementById('current-difficulty');
    const gameStatusEl = document.getElementById('game-status');
    const pencilModeBtn = document.getElementById('pencilModeBtn'); // Manual pencil mode button
    const autoPencilBtn = document.getElementById('autoPencilBtn'); // New: Auto pencil button

    // --- Sudoku Core Logic (Backtracking for Generation and Solving) ---

    // Function to check if a number is valid in a given cell
    function isValid(board, row, col, num) {
      // Check row
      for (let x = 0; x < 9; x++) {
        if (board[row][x] === num && x !== col) {
          return false;
        }
      }

      // Check column
      for (let x = 0; x < 9; x++) {
        if (board[x][col] === num && x !== row) {
          return false;
        }
      }

      // Check 3x3 box
      const startRow = row - (row % 3);
      const startCol = col - (col % 3);
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          if (board[i + startRow][j + startCol] === num && (i + startRow !== row || j + startCol !== col)) {
            return false;
          }
        }
      }
      return true;
    }

    // Function to find the next empty cell (0)
    function findEmpty(board) {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] === 0) {
            return [r, c];
          }
        }
      }
      return null; // No empty cells
    }

    // Backtracking solver
    function solve(currentBoard) {
      const find = findEmpty(currentBoard);
      if (!find) {
        return true; // Board is solved
      }
      const [row, col] = find;

      for (let num = 1; num <= 9; num++) {
        if (isValid(currentBoard, row, col, num)) {
          currentBoard[row][col] = num;

          if (solve(currentBoard)) {
            return true;
          }

          currentBoard[row][col] = 0; // Backtrack
        }
      }
      return false; // No solution found
    }

    // New: Function to check if the puzzle is solvable from the current state (simple forward check)
    function isPuzzleSolvable(currentBoard) {
        let tempBoard = JSON.parse(JSON.stringify(currentBoard)); // Work on a copy
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                if (tempBoard[r][c] === 0) { // If cell is empty
                    const possibilities = calculatePossibleNumbers(tempBoard, r, c);
                    if (possibilities.size === 0) {
                        return false; // Found an empty cell with no possible candidates
                    }
                }
            }
        }
        // If all empty cells have at least one candidate, try a full solve
        return solve(tempBoard);
    }


    // --- Sudoku Puzzle Generation ---
    function generateSudoku(difficultyLevel) {
      // 1. Create a completely solved board
      let tempBoard = Array(9).fill(0).map(() => Array(9).fill(0));
      // Fill the board using the solver
      fillBoard(tempBoard);
      solution = JSON.parse(JSON.stringify(tempBoard)); // Store the full solution

      // 2. Remove numbers based on difficulty
      let cellsToRemove = 0;
      switch (difficultyLevel) {
        case 'easy':
          cellsToRemove = 40; // Fewer cells removed for easier puzzles
          break;
        case 'medium':
          cellsToRemove = 50; // Standard number
          break;
        case 'hard':
          cellsToRemove = 60; // More cells removed for harder puzzles
          break;
      }

      let count = 0;
      while (count < cellsToRemove) {
        const row = Math.floor(Math.random() * 9);
        const col = Math.floor(Math.random() * 9);

        if (tempBoard[row][col] !== 0) {
          const tempValue = tempBoard[row][col];
          tempBoard[row][col] = 0; // Temporarily remove

          // Check if the puzzle is still solvable (simple check, not uniqueness)
          let testBoard = JSON.parse(JSON.stringify(tempBoard));
          if (solve(testBoard)) {
            count++;
          } else {
            tempBoard[row][col] = tempValue; // If not solvable, put it back
          }
        }
      }
      initialBoard = JSON.parse(JSON.stringify(tempBoard)); // Store the initial puzzle
      board = JSON.parse(JSON.stringify(tempBoard)); // Set current board to the puzzle
      // Reset userPencilMarks for new game
      userPencilMarks = Array(9).fill(0).map(() => Array(9).fill(0).map(() => new Set()));
    }

    // Helper to fill a board for generation (different from solve, ensures a full board)
    function fillBoard(currentBoard) {
        for (let i = 0; i < 81; i++) {
            let row = Math.floor(i / 9);
            let col = i % 9;
            if (currentBoard[row][col] === 0) {
                let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5); // Randomize numbers
                for (let num of numbers) {
                    if (isValid(currentBoard, row, col, num)) {
                        currentBoard[row][col] = num;
                        if (fillBoard(currentBoard)) {
                            return true;
                        } else {
                            currentBoard[row][col] = 0; // Backtrack
                        }
                    }
                }
                return false;
            }
        }
        return true;
    }


    // --- Game Initialization ---
    function initializeGame() {
      gameEnded = false;
      selectedCell = null;
      selectedNumberFromPad = null; // Reset selected number highlight
      hideGameMessage();
      generateSudoku(difficulty); // Generate a new puzzle
      // Reset userPencilMarks for new game
      userPencilMarks = Array(9).fill(0).map(() => Array(9).fill(0).map(() => new Set()));
      renderBoard(); // Initial render will use empty userPencilMarks or auto-generated if autoPencilMode is on
      updateHUD();
      gameStatusEl.textContent = 'Playing'; // Reset status on new game
      pencilMode = false; // Reset manual pencil mode on new game
      autoPencilMode = false; // Reset auto pencil mode on new game
      updatePencilModeButton(); // Update button text on new game
      updateAutoPencilButton(); // Update button text on new game
    }

    // --- Rendering Functions ---
    function renderBoard() {
      sudokuBoardEl.innerHTML = ''; // Clear existing board
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const cellEl = document.createElement('div');
          cellEl.classList.add('sudoku-cell');
          cellEl.dataset.row = r;
          cellEl.dataset.col = c;

          // Remove previous error/highlight classes before re-rendering
          cellEl.classList.remove('unsolvable-error', 'highlight-number-selection');

          // Add classes for 3x3 block borders
          if (r % 3 === 0 && r !== 0) {
            cellEl.style.borderTopWidth = '2px';
            cellEl.style.borderTopColor = '#555';
          }
          if (c % 3 === 0 && c !== 0) {
            cellEl.style.borderLeftWidth = '2px';
            cellEl.style.borderLeftColor = '#555';
          }

          if (initialBoard[r][c] !== 0) {
            cellEl.textContent = initialBoard[r][c];
            cellEl.classList.add('fixed'); // Fixed numbers cannot be changed
          } else if (board[r][c] !== 0) {
            cellEl.textContent = board[r][c];
            // If a main number is present, clear pencil marks for that cell
            userPencilMarks[r][c].clear(); // Clear user marks if a number is placed
          } else {
            // Determine which pencil marks to display
            let marksToDisplay = new Set();
            if (autoPencilMode) {
                // If auto pencil is on, calculate and display auto candidates
                marksToDisplay = calculatePossibleNumbers(board, r, c);
            } else {
                // If auto pencil is off, display user's manual marks
                marksToDisplay = userPencilMarks[r][c];
            }

            const pencilMarksContainer = document.createElement('div');
            pencilMarksContainer.classList.add('pencil-marks');
            const sortedMarks = Array.from(marksToDisplay).sort((a, b) => a - b);
            
            // Only append pencil marks if there are any
            if (sortedMarks.length > 0) {
                for (let i = 1; i <= 9; i++) {
                    const markEl = document.createElement('div');
                    if (sortedMarks.includes(i)) {
                        markEl.textContent = i;
                        // New: Highlight matching pencil marks
                        if (selectedNumberFromPad !== null && i === selectedNumberFromPad) {
                            markEl.classList.add('highlighted-pencil-mark');
                        }
                    }
                    pencilMarksContainer.appendChild(markEl);
                }
                cellEl.appendChild(pencilMarksContainer);
            }
          }

          // New: Add highlight for selected number from pad for main numbers
          if (selectedNumberFromPad !== null && board[r][c] === selectedNumberFromPad) {
              cellEl.classList.add('highlight-number-selection');
          }

          cellEl.addEventListener('click', handleCellClick);
          sudokuBoardEl.appendChild(cellEl);
        }
      }
      highlightSelectedCell();
    }

    function highlightSelectedCell() {
        document.querySelectorAll('.sudoku-cell').forEach(cellEl => {
            cellEl.classList.remove('selected', 'invalid', 'highlight-same-value', 'highlight-group');
            // Ensure unsolvable-error is also cleared when re-highlighting
            if (!cellEl.classList.contains('unsolvable-error')) { // Don't remove if it's a persistent error
                cellEl.classList.remove('unsolvable-error');
            }
        });

        if (selectedCell) {
            const { row, col } = selectedCell;
            const selectedEl = document.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${col}"]`);
            if (selectedEl) {
                selectedEl.classList.add('selected');
            }

            // Highlight row, column, and 3x3 block
            for (let i = 0; i < 9; i++) {
                document.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${i}"]`).classList.add('highlight-group');
                document.querySelector(`.sudoku-cell[data-row="${i}"][data-col="${col}"]`).classList.add('highlight-group');
            }
            const startRow = row - (row % 3);
            const startCol = col - (col % 3);
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    document.querySelector(`.sudoku-cell[data-row="${i + startRow}"][data-col="${j + startCol}"]`).classList.add('highlight-group');
                }
            }

            // Highlight cells with the same value as the selected cell (if it has a value)
            const selectedValue = board[row][col];
            if (selectedValue !== 0) {
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (board[r][c] === selectedValue) {
                            document.querySelector(`.sudoku-cell[data-row="${r}"][data-col="${c}"]`).classList.add('highlight-same-value');
                        }
                    }
                }
            }
        }
    }

    function updateHUD() {
      currentDifficultyEl.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
    }

    // Function to display messages. If isGameOver is true, message persists.
    function displayGameMessage(message, isGameOver = false) {
      clearTimeout(messageTimeoutId); // Clear any existing timeout
      messageTimeoutId = null;

      gameMessageEl.textContent = message;
      gameMessageEl.style.display = 'block';
      if (isGameOver) {
        gameMessageEl.classList.add('game-over-style'); // Add style for game over
      } else {
        gameMessageEl.classList.remove('game-over-style'); // Remove style for temporary messages
        messageTimeoutId = setTimeout(hideGameMessage, 2000); // Hide temporary messages after 2 seconds
      }
    }

    function hideGameMessage() {
      gameMessageEl.style.display = 'none';
      gameMessageEl.classList.remove('game-over-style'); // Ensure style is removed when hidden
    }

    // --- Game Logic ---
    function handleCellClick(event) {
      if (gameEnded) {
        displayGameMessage("Game over! Start a New Game.");
        return;
      }

      const row = parseInt(event.currentTarget.dataset.row);
      const col = parseInt(event.currentTarget.dataset.col);

      if (initialBoard[row][col] !== 0) {
        selectedCell = null; // Cannot select fixed cells
        displayGameMessage("This is a fixed number!");
      } else {
        selectedCell = { row, col };
      }
      // Clear number pad highlight when a cell is clicked
      selectedNumberFromPad = null;
      renderBoard(); // Re-render to update highlights
    }

    // Helper to calculate possible numbers for a given cell
    function calculatePossibleNumbers(currentBoard, row, col) {
        const possibilities = new Set();
        for (let num = 1; num <= 9; num++) {
            if (isValid(currentBoard, row, col, num)) {
                possibilities.add(num);
            }
        }
        return possibilities;
    }

    // Function to update pencil marks display based on current mode
    function updatePencilMarksDisplay() {
        renderBoard(); // Re-render to show correct pencil marks (auto or manual)
    }

    function handleNumberInput(event) {
      if (!selectedCell || gameEnded) return;

      const value = event.target.dataset.value;
      const { row, col } = selectedCell;
      const selectedEl = document.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${col}"]`);


      if (initialBoard[row][col] !== 0) { // Cannot change fixed cells
        displayGameMessage("Cannot change fixed numbers!");
        selectedNumberFromPad = null; // Clear highlight if fixed cell is selected
        renderBoard();
        return;
      }

      // Clear any previous error state on the selected cell
      selectedEl.classList.remove('unsolvable-error');

      if (pencilMode) {
        // Manual Pencil mode logic: update userPencilMarks
        if (value === 'clear') {
          userPencilMarks[row][col].clear(); // Clear all user pencil marks
        } else {
          const num = parseInt(value);
          if (userPencilMarks[row][col].has(num)) {
            userPencilMarks[row][col].delete(num); // Toggle off
          } else {
            userPencilMarks[row][col].add(num); // Toggle on
          }
        }
        board[row][col] = 0; // Ensure main number is cleared in manual pencil mode
        selectedNumberFromPad = null; // Clear number pad highlight in pencil mode
      } else {
        // Normal input mode logic
        if (value === 'clear') {
          board[row][col] = 0;
          selectedNumberFromPad = null; // Clear number pad highlight
        } else {
          const num = parseInt(value);
          board[row][col] = num;
          userPencilMarks[row][col].clear(); // Clear user pencil marks when setting a main number
          selectedNumberFromPad = num; // Set selected number for highlighting
        }
      }

      // After any input, re-render the board to reflect changes based on current mode
      updatePencilMarksDisplay(); // This will re-evaluate what to display

      // Validate the current input if it's not a clear and not in any pencil mode
      if (value !== 'clear' && !pencilMode && !autoPencilMode) {
        if (!isValid(board, row, col, board[row][col])) {
          selectedEl.classList.add('invalid');
          displayGameMessage("Invalid move!");
          gameStatusEl.textContent = 'Invalid!';
        } else {
          // New: Check for puzzle solvability after a valid move
          if (!isPuzzleSolvable(board)) {
              selectedEl.classList.add('unsolvable-error');
              displayGameMessage("Invalid move: Puzzle became unsolvable!", false); // Not game over, but an error
              gameStatusEl.textContent = 'Error!';
          } else {
              // If valid and solvable, check for win condition
              if (checkWin()) {
                displayGameMessage("Congratulations! You solved the Sudoku!", true);
                gameStatusEl.textContent = 'Solved!';
                gameEnded = true;
              } else {
                gameStatusEl.textContent = 'Playing';
              }
          }
        }
      } else {
          gameStatusEl.textContent = 'Playing'; // Always set to Playing for consistency
      }
    }


    function checkWin() {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] === 0 || !isValid(board, r, c, board[r][c])) {
            return false;
          }
        }
      }
      return true;
    }

    function solveCurrentPuzzle() {
        if (gameEnded) {
            displayGameMessage("Game over! Start a New Game to solve a new puzzle.");
            return;
        }
        // Clear any error states before solving
        document.querySelectorAll('.unsolvable-error').forEach(el => el.classList.remove('unsolvable-error'));
        // Use the stored solution to fill the board
        board = JSON.parse(JSON.stringify(solution));
        userPencilMarks = Array(9).fill(0).map(() => Array(9).fill(0).map(() => new Set())); // Clear user pencil marks
        selectedNumberFromPad = null; // Clear number pad highlight
        updatePencilMarksDisplay(); // Re-render to clear pencil marks
        updateHUD();
        displayGameMessage("Puzzle solved!", true);
        gameStatusEl.textContent = 'Solved!';
        gameEnded = true;
        selectedCell = null; // Deselect any cell
    }

    // Function to update the manual pencil mode button's text and active state
    function updatePencilModeButton() {
        if (pencilMode) {
            pencilModeBtn.classList.add('active-mode');
            pencilModeBtn.textContent = '✏️ Pencil Mode ON';
        } else {
            pencilModeBtn.classList.remove('active-mode');
            pencilModeBtn.textContent = '✏️ Pencil Mode OFF';
        }
        // Deselect cell and clear number highlight when toggling pencil mode OFF
        if (!pencilMode && selectedCell) {
            selectedCell = null;
            selectedNumberFromPad = null;
            highlightSelectedCell(); // Re-render to remove selection highlight
        }
    }

    // New: Function to update the auto pencil mode button's text and active state
    function updateAutoPencilButton() {
        if (autoPencilMode) {
            autoPencilBtn.classList.add('active-mode');
            autoPencilBtn.textContent = '📝 Auto Pencil ON';
        } else {
            autoPencilBtn.classList.remove('active-mode');
            autoPencilBtn.textContent = '📝 Auto Pencil OFF';
        }
        // Deselect cell and clear number highlight when toggling auto pencil mode OFF
        if (!autoPencilMode && selectedCell) {
            selectedCell = null;
            selectedNumberFromPad = null;
            highlightSelectedCell(); // Re-render to remove selection highlight
        }
    }


    // --- Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
      newGameBtn.addEventListener('click', initializeGame);
      solveBtn.addEventListener('click', solveCurrentPuzzle);

      pencilModeBtn.addEventListener('click', () => {
        pencilMode = !pencilMode;
        if (pencilMode) { // If manual pencil mode is turned ON, turn auto pencil mode OFF
            autoPencilMode = false;
        }
        updatePencilModeButton(); // Update button text and style immediately
        updateAutoPencilButton(); // Ensure auto pencil button is updated
        updatePencilMarksDisplay(); // Re-render to show correct pencil marks (manual or none)
        gameStatusEl.textContent = 'Playing'; // Always set to Playing for consistency
      });

      autoPencilBtn.addEventListener('click', () => {
        autoPencilMode = !autoPencilMode;
        if (autoPencilMode) { // If auto pencil mode is turned ON, turn manual pencil mode OFF
            pencilMode = false;
        }
        updatePencilModeButton(); // Ensure manual pencil button is updated
        updateAutoPencilButton(); // Update button text and style immediately
        updatePencilMarksDisplay(); // Re-render to show correct pencil marks (auto or manual)
        gameStatusEl.textContent = 'Playing'; // Always set to Playing for consistency
      });


      difficultySelect.addEventListener('change', (event) => {
        difficulty = event.target.value;
        initializeGame();
        displayGameMessage(`Difficulty set to ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`);
      });

      numberPadEl.querySelectorAll('button').forEach(button => {
        button.addEventListener('click', handleNumberInput);
      });

      // Share and Copy Link buttons (same as Chess)
      document.getElementById('shareBtn').onclick = () => {
        if (navigator.share) {
          navigator.share({
            title: "Sudoku - No Spin Media",
            url: window.location.href
          }).catch((error) => console.error('Error sharing:', error));
        } else {
          const dummyTextArea = document.createElement('textarea');
          dummyTextArea.value = window.location.href;
          document.body.appendChild(dummyTextArea);
          dummyTextArea.select();
          document.execCommand('copy');
          document.body.removeChild(dummyTextArea);
          displayGameMessage("Link copied to clipboard!");
        }
      };
      document.getElementById('copyBtn').onclick = () => {
        const dummyTextArea = document.createElement('textarea');
        dummyTextArea.value = window.location.href;
        document.body.appendChild(dummyTextArea);
        dummyTextArea.select();
        document.execCommand('copy');
        document.body.removeChild(dummyTextArea);
        displayGameMessage("Link copied to clipboard!");
      };

      // Initial game setup
      initializeGame();
    });
  </script>
</body>
</html>
