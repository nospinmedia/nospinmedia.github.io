<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sudoku - No Spin Media</title>
  <link rel="stylesheet" href="/style.css">
  <style>
    /* Global box-sizing for consistent layout */
    * {
      box-sizing: border-box;
    }

    /* Global body styles for the game theme - same as chess */
    body {
      background: #222831; /* Deep charcoal for a calm background */
      color: #fff;
      margin: 0;
      font-family: 'Inter', Arial, sans-serif; /* Using Inter for a modern look */
      display: flex;
      flex-direction: column;
      min-height: 100vh; /* Ensure footer stays at bottom */
    }

    /* New wrapper for header and game content to control mobile order */
    #main-content-wrapper {
        display: flex;
        flex-direction: column; /* Default: header on top */
        flex-grow: 1; /* Allow it to grow and push footer down */
    }

    /* Site header styling (adjust if needed, but usually handled by /header.html's CSS) */
    #site-header {
        width: 100%; /* Ensure it takes full width */
    }

    /* Main game container layout - same as chess */
    #game-container {
      display: flex;
      justify-content: center;
      padding: 20px;
      gap: 30px;
      flex-wrap: wrap; /* Allows wrapping on smaller screens */
      flex-grow: 1; /* Allows container to grow and push footer down */
    }

    /* Game box styling (main game area) - same as chess */
    #game-box {
      border: 2px solid #74B9FF; /* Muted blue border */
      box-shadow: 0 0 20px #74B9FF; /* Muted blue glow */
      padding: 20px; /* Increased padding */
      border-radius: 12px; /* More rounded corners */
      background: #222831; /* Match body background */
      position: relative;
      flex-grow: 1;
      max-width: 380px; /* Adjusted max-width for desktop to fit smaller board */
      width: 100%; /* Ensure it takes full width within max-width */
      min-width: 320px;
      display: flex;
      flex-direction: column;
    }

    /* Game header styling - same as chess */
    #game-header {
      color: #74B9FF;
      text-align: center;
      font-size: 2.2em;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #74B9FF;
      position: relative;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(116, 185, 255, 0.3);
    }

    #game-version {
      position: absolute;
      top: 5px;
      right: 15px;
      color: #74B9FF;
      font-size: 0.7em;
      opacity: 0.7;
    }

    /* Game info (messages) - using for Sudoku messages */
    #game-info {
      text-align: center;
      color: #74B9FF;
      margin-bottom: 15px;
      font-weight: bold;
      font-size: 1.1em;
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      gap: 10px;
      min-height: 30px; /* Ensure a consistent height to prevent shifts */
    }
    #game-info span {
      padding: 5px 10px;
      background: rgba(116, 185, 255, 0.1);
      border-radius: 5px;
    }

    /* Game controls/buttons */
    .game-controls {
      text-align: center;
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap; /* Allows wrapping */
      gap: 10px;
      max-width: 100%; /* Ensure it respects parent width */
      justify-content: center; /* Center items within the flex container */
    }

    .game-controls button,
    .game-controls select {
      padding: 5px 8px; /* Further reduced padding to make buttons less tall */
      margin: 0; /* Remove individual margins as gap handles spacing */
      background: #60A3D9;
      color: #000;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 0.8em; /* Slightly smaller font for buttons */
      box-shadow: 0 0 10px rgba(96, 163, 217, 0.5);
      transition: all 0.2s ease-in-out;
      flex-grow: 1; /* Allow items to grow */
      flex-shrink: 1; /* Allow items to shrink */
      min-width: 80px; /* Minimum width to prevent squishing */
    }

    /* Specific widths for top row buttons to ensure 3 fit */
    .game-controls #newGameBtn,
    .game-controls #difficultySelect,
    .game-controls #solveBtn {
        flex-basis: calc(33.33% - 10px); /* Roughly 1/3 width each, accounting for gap */
        max-width: calc(33.33% - 10px);
    }

    /* Specific widths for second row buttons to ensure 2 fit */
    .game-controls #shareBtn,
    .game-controls #copyBtn {
        flex-basis: calc(50% - 10px); /* Roughly 1/2 width each, accounting for gap */
        max-width: calc(50% - 10px);
    }

    .game-controls button:hover,
    .game-controls select:hover {
      background: #7ABCEF;
      box-shadow: 0 0 15px rgba(122, 188, 239, 0.8);
      transform: translateY(-2px);
    }

    .game-controls button:active,
    .game-controls select:active {
      transform: translateY(0);
      box-shadow: 0 0 5px rgba(96, 163, 217, 0.3);
    }

    /* Difficulty dropdown */
    .game-controls select {
        border: 1px solid #60A3D9;
        background-color: #2E4057;
        color: #fff;
        font-size: 0.8em; /* Match button font size */
        outline: none;
    }


    /* Sidebar styling (Donate section) - same as chess */
    #sidebar {
      background: #222831;
      border: 2px solid #74B9FF;
      box-shadow: 0 0 15px #74B9FF;
      padding: 20px;
      border-radius: 8px;
      max-width: 280px;
      height: fit-content;
      text-align: center;
      margin-top: 15px;
      flex-shrink: 0; /* Prevent sidebar from shrinking */
    }

    #sidebar h2 {
      color: #74B9FF;
      text-align: center;
      margin-bottom: 15px;
    }

    #donate-button {
      background: #ffd700;
      color: #000;
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin: 15px auto 10px;
      display: block;
      transition: all 0.2s ease-in-out;
    }

    #donate-button:hover {
      background: #ffe033;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
      transform: translateY(-2px);
    }

    #donate-button:active {
      transform: translateY(0);
      box-shadow: 0 0 5px rgba(96, 163, 217, 0.3);
    }

    #sidebar p {
      font-size: 0.9em;
      color: #aaa;
      line-height: 1.4;
    }

    /* Footer styling - same as chess */
    footer {
      text-align: center;
      color: #666;
      padding: 15px;
      font-size: 0.9em;
      margin-top: auto;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* --- Sudoku Board Specific Layout --- */
    #sudoku-board {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      width: 100%; /* Make board take 100% of parent's width */
      aspect-ratio: 1 / 1; /* Keep it square */
      margin: 10px auto;
      border: 4px solid #74B9FF;
      box-shadow: 0 0 25px rgba(116, 185, 255, 0.5);
      border-radius: 8px;
      overflow: hidden;
      flex-shrink: 0;
      max-width: 340px; /* Adjusted max width for desktop board (approx 1/3 smaller) */
    }

    .sudoku-cell {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2em; /* Adjusted font size for desktop */
      font-weight: bold;
      cursor: pointer;
      border: 1px solid #333;
      background-color: #AEC6CF;
      color: #000;
      transition: background-color 0.2s ease-in-out;
      position: relative; /* For pencil marks positioning */
      min-height: 38px; /* Added min-height to prevent shifts when pencil marks appear/disappear */
    }

    /* Pencil marks grid inside cell */
    .sudoku-cell .pencil-marks {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        width: 100%;
        height: 100%;
        font-size: 0.5em; /* Further reduced font size for pencil marks */
        color: #fff; /* Changed to white for better visibility */
        font-weight: normal;
        gap: 1px;
        padding: 1px; /* Reduced padding */
    }
    .sudoku-cell .pencil-marks div {
        display: flex;
        justify-content: center;
        align-items: center;
    }


    /* Darker background for 3x3 blocks */
    .sudoku-cell:nth-child(3n):not(:last-child) {
        border-right: 2px solid #555;
    }
    .sudoku-cell:nth-child(9n) {
        border-right: 1px solid #333; /* Reset for last column */
    }
    .sudoku-cell:nth-child(n) {
        border-bottom: 1px solid #333;
    }
    .sudoku-cell:nth-child(n + 19):nth-child(-n + 27),
    .sudoku-cell:nth-child(n + 46):nth-child(-n + 54) {
        border-bottom: 2px solid #555;
    }
    /* Specific styling for 3x3 block borders */
    .sudoku-cell:nth-child(3n+1) { border-left: 1px solid #333; }
    .sudoku-cell:nth-child(9n+1) { border-left: 1px solid #333; }

    .sudoku-cell.fixed {
      background-color: #4A6572;
      color: #F8F8F8;
      cursor: default;
    }

    .sudoku-cell.selected {
      background-color: #4682B4;
      box-shadow: inset 0 0 10px #4682B4;
    }

    .sudoku-cell.invalid {
      background-color: #FF6347;
      color: #fff;
    }

    .sudoku-cell.highlight-same-value {
        background-color: #87CEEB;
    }

    .sudoku-cell.highlight-group {
        background-color: rgba(116, 185, 255, 0.3);
    }

    /* Number input pad */
    #number-pad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: auto; /* Pushes to bottom of flex container */
      padding: 10px;
      border-radius: 8px;
      background: #2E4057;
    }

    #number-pad button {
      padding: 8px; /* Reduced padding for number buttons */
      background: #60A3D9;
      color: #000;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      font-size: 0.8em; /* Adjusted font size for desktop */
      cursor: pointer;
      box-shadow: 0 0 8px rgba(96, 163, 217, 0.5);
      transition: all 0.2s ease-in-out;
    }

    #number-pad button:hover {
      background: #7ABCEF;
      box-shadow: 0 0 12px rgba(122, 188, 239, 0.8);
      transform: translateY(-2px);
    }

    #number-pad button:active {
      transform: translateY(0);
      box-shadow: 0 0 4px rgba(96, 163, 217, 0.3);
    }

    /* Adjust grid for Clear and Pencil Mode to be side-by-side */
    #number-pad .bottom-row-buttons {
        grid-column: span 3; /* Container for these two buttons spans all 3 columns */
        display: flex;
        gap: 10px;
        justify-content: space-between; /* Distribute space evenly */
    }

    #number-pad button.clear-button,
    #number-pad button.pencil-mode-button,
    #number-pad button.auto-pencil-button { /* Added auto-pencil-button */
      flex: 1 1 calc(33.33% - 7px); /* Each takes roughly 1/3 space minus gap for 3 buttons */
      padding: 8px 5px; /* Reduced padding for 3 buttons */
      background: #FF6347; /* Default color for Clear */
      color: #fff;
      font-size: 0.75em; /* Slightly smaller font for 3 buttons */
    }
    #number-pad button.clear-button {
        background: #FF6347; /* Red for Clear */
    }
    #number-pad button.clear-button:hover {
        background: #FF7F50;
    }
    #number-pad button.pencil-mode-button {
        background: #60A3D9; /* Blue for Pencil Mode */
    }
    #number-pad button.pencil-mode-button:hover {
        background: #7ABCEF;
    }
    #number-pad button.auto-pencil-button { /* Style for Auto Pencil button */
        background: #28a745; /* Green for Auto Pencil */
    }
    #number-pad button.auto-pencil-button:hover {
        background: #218838;
    }

    #number-pad button.pencil-mode-button.active-mode {
        background: #FFD700; /* Gold for active pencil mode */
        color: #000;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
    }
    #number-pad button.auto-pencil-button.active-mode { /* Style for active Auto Pencil button */
        background: #FFD700; /* Gold for active auto pencil mode */
        color: #000;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
    }


    /* Game message box (for all messages) - same as chess */
    #game-message {
      position: relative;
      margin: 10px auto;
      background: rgba(0,0,0,0.8);
      padding: 10px 20px;
      border-radius: 8px;
      border: 2px solid #74B9FF;
      color: #74B9FF;
      font-size: 1.5em;
      font-weight: bold;
      text-shadow: 0 0 5px #74B9FF;
      display: none;
      text-align: center;
      width: fit-content;
      max-width: 80%;
      z-index: 1001;
    }

    /* Style for game over message - same as chess */
    #game-message.game-over-style {
      color: #FFD700;
      font-size: 2.5em;
      text-shadow: 0 0 20px #FFD700;
      padding: 20px 30px;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      /* Reverse order of header and game container on mobile */
      #main-content-wrapper {
          flex-direction: column-reverse;
      }

      #game-container {
        flex-direction: column;
        align-items: center;
        padding: 10px;
      }
      #game-box {
        width: 100%;
        max-width: none; /* Allow full width on mobile */
        padding: 1vw; /* Responsive padding on mobile */
      }
      #sidebar {
        width: 100%;
        max-width: none;
        margin-top: 20px;
      }
      #sudoku-board {
        width: 90vw; /* Adjusted to 90vw for more space */
        height: 90vw; /* Adjusted to 90vw */
        max-width: 630px; /* Still cap max size for larger tablets */
        max-height: 630px;
        margin: 1vw auto; /* Responsive margin on mobile */
      }
      .sudoku-cell {
        width: calc(90vw / 9); /* Ensures 9 cells fit within 90vw board */
        height: calc(90vw / 9);
        font-size: 4.5vw; /* Adjusted font size responsively */
        min-height: 10vw; /* Responsive min-height for mobile cells */
      }
      .sudoku-cell .pencil-marks {
          font-size: 1.5vw; /* Further smaller font for pencil marks on mobile */
          padding: 0.3vw;
      }
      #number-pad {
        margin-top: 1vw; /* Responsive margin on mobile */
        padding: 1.5vw; /* Responsive padding on mobile */
        grid-template-columns: repeat(3, 1fr); /* 3 columns for numbers */
      }
      #number-pad button {
        font-size: 3vw; /* Responsive font size for buttons */
        padding: 1.2vw; /* Responsive padding */
      }
      #number-pad .bottom-row-buttons {
          grid-column: span 3; /* On mobile, the container spans 3 columns */
          flex-direction: row; /* Ensure they stay side by side */
          justify-content: space-around;
      }
      #number-pad button.clear-button,
      #number-pad button.pencil-mode-button,
      #number-pad button.auto-pencil-button { /* Added auto-pencil-button */
        flex: 1 1 auto; /* Allow them to size automatically within the flex container */
        font-size: 2.8vw; /* Match other buttons */
        padding: 1.2vw 0.8vw; /* Match other buttons, slightly less horizontal padding */
      }
      .game-controls {
        margin-bottom: 2vw; /* Responsive margin on mobile */
        gap: 1.5vw; /* Responsive gap */
      }
      .game-controls button {
        font-size: 2.5vw; /* Responsive font size */
        padding: 0.8vw 1.5vw; /* Responsive padding */
      }
      .game-controls select {
        font-size: 2.5vw; /* Responsive font size */
        padding: 0.8vw 1.5vw;
      }
      #game-header {
        font-size: 5vw; /* Responsive header font size */
        margin-bottom: 2vw;
      }
      #game-version {
        font-size: 2vw;
        right: 3vw;
        top: 1.5vw;
      }
      #game-info {
        margin-bottom: 2vw;
        font-size: 2.8vw; /* Responsive info font size */
        gap: 2vw;
      }
      #game-info span {
        padding: 1vw 2vw;
      }
      #game-message {
        font-size: 3.5vw; /* Responsive messages font size */
        padding: 2vw 4vw;
        margin: 2vw auto;
      }
      #game-message.game-over-style {
        font-size: 5vw; /* Responsive game over message font size */
        padding: 3vw 5vw;
      }
    }
  </style>
</head>
<body>

  <div id="main-content-wrapper">
    <!-- Site-wide header (fetched dynamically) -->
    <div id="site-header"></div> 
    <div id="game-container">
      <div id="game-box">
        <div id="game-header">Sudoku 🧩 <span id="game-version">v2.12</span></div>
        <div id="game-info">
          <span>Difficulty: <span id="current-difficulty">Medium</span></span>
          <span id="game-status">Ready</span>
        </div>

        <div class="game-controls">
          <button id="newGameBtn">✨ New Game</button>
          <select id="difficultySelect">
              <option value="easy">Easy</option>
              <option value="medium" selected>Medium</option>
              <option value="hard">Hard</option>
          </select>
          <button id="solveBtn">💡 Solve</button>
          <button id="shareBtn">🔗 Share with Friends</button>
          <button id="copyBtn">📋 Copy Link</button>
        </div>

        <!-- Game message box for notifications -->
        <div id="game-message"></div>

        <div id="sudoku-board">
          <!-- Sudoku cells will be dynamically generated here -->
        </div>

        <div id="number-pad">
          <button data-value="1">1</button>
          <button data-value="2">2</button>
          <button data-value="3">3</button>
          <button data-value="4">4</button>
          <button data-value="5">5</button>
          <button data-value="6">6</button>
          <button data-value="7">7</button>
          <button data-value="8">8</button>
          <button data-value="9">9</button>
          <div class="bottom-row-buttons">
              <button data-value="clear" class="clear-button">Clear</button>
              <button id="autoPencilBtn" class="auto-pencil-button">📝 Auto Pencil OFF</button>
              <button id="pencilModeBtn" class="pencil-mode-button">✏️ Pencil Mode OFF</button>
          </div>
        </div>
      </div>

      <!-- Sidebar (Donate section) -->
      <div id="sidebar">
        <h2>Support Us!</h2>
        <p>If you enjoy ad-free games from No Spin Media, consider supporting us.</p>
        <button id="donate-button" onclick="window.location.href='/sponsor.html'">Donate Now</button>
        <p style="font-size:0.8em; color:#aaa;">Your help keeps No Spin Media alive and growing.</p>
      </div>
    </div>
  </div>

  <!-- Site-wide footer -->
  <footer>
    © 2025 No Spin Media. Independent. Ad-free. Truth-focused.
  </footer>

  <script>
    // Fetch header content and inject it into the correct div
    fetch(window.location.origin + '/header.html')
      .then(r => r.text())
      .then(h => document.getElementById('site-header').innerHTML = h)
      .catch(e => console.error('Error fetching header:', e));

    // --- Game State Variables ---
    let board = Array(9).fill(0).map(() => Array(9).fill(0)); // Current state of the board
    let solution = Array(9).fill(0).map(() => Array(9).fill(0)); // Solved board
    let initialBoard = Array(9).fill(0).map(() => Array(9).fill(0)); // Initial puzzle with fixed numbers
    let selectedCell = null; // { row, col } of the currently selected cell
    let difficulty = 'medium'; // 'easy', 'medium', 'hard'
    let messageTimeoutId = null; // To manage the hide timeout for temporary messages
    let gameEnded = false; // Flag to indicate if the game has ended
    let pencilMode = false; // Manual pencil mode state
    let autoPencilMode = false; // New: Auto pencil mode state
    // New: Store pencil marks for each cell
    let pencilMarks = Array(9).fill(0).map(() => Array(9).fill(0).map(() => new Set()));


    // --- DOM Elements ---
    const sudokuBoardEl = document.getElementById('sudoku-board');
    const numberPadEl = document.getElementById('number-pad');
    const newGameBtn = document.getElementById('newGameBtn');
    const solveBtn = document.getElementById('solveBtn');
    const difficultySelect = document.getElementById('difficultySelect');
    const gameMessageEl = document.getElementById('game-message');
    const currentDifficultyEl = document.getElementById('current-difficulty');
    const gameStatusEl = document.getElementById('game-status');
    const pencilModeBtn = document.getElementById('pencilModeBtn'); // Manual pencil mode button
    const autoPencilBtn = document.getElementById('autoPencilBtn'); // New: Auto pencil button

    // --- Sudoku Core Logic (Backtracking for Generation and Solving) ---

    // Function to check if a number is valid in a given cell
    function isValid(board, row, col, num) {
      // Check row
      for (let x = 0; x < 9; x++) {
        if (board[row][x] === num && x !== col) {
          return false;
        }
      }

      // Check column
      for (let x = 0; x < 9; x++) {
        if (board[x][col] === num && x !== row) {
          return false;
        }
      }

      // Check 3x3 box
      const startRow = row - (row % 3);
      const startCol = col - (col % 3);
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          if (board[i + startRow][j + startCol] === num && (i + startRow !== row || j + startCol !== col)) {
            return false;
          }
        }
      }
      return true;
    }

    // Function to find the next empty cell (0)
    function findEmpty(board) {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] === 0) {
            return [r, c];
          }
        }
      }
      return null; // No empty cells
    }

    // Backtracking solver
    function solve(currentBoard) {
      const find = findEmpty(currentBoard);
      if (!find) {
        return true; // Board is solved
      }
      const [row, col] = find;

      for (let num = 1; num <= 9; num++) {
        if (isValid(currentBoard, row, col, num)) {
          currentBoard[row][col] = num;

          if (solve(currentBoard)) {
            return true;
          }

          currentBoard[row][col] = 0; // Backtrack
        }
      }
      return false; // No solution found
    }

    // --- Sudoku Puzzle Generation ---
    function generateSudoku(difficultyLevel) {
      // 1. Create a completely solved board
      let tempBoard = Array(9).fill(0).map(() => Array(9).fill(0));
      // Fill the board using the solver
      fillBoard(tempBoard);
      solution = JSON.parse(JSON.stringify(tempBoard)); // Store the full solution

      // 2. Remove numbers based on difficulty
      let cellsToRemove = 0;
      switch (difficultyLevel) {
        case 'easy':
          cellsToRemove = 40; // Fewer cells removed for easier puzzles
          break;
        case 'medium':
          cellsToRemove = 50; // Standard number
          break;
        case 'hard':
          cellsToRemove = 60; // More cells removed for harder puzzles
          break;
      }

      let count = 0;
      while (count < cellsToRemove) {
        const row = Math.floor(Math.random() * 9);
        const col = Math.floor(Math.random() * 9);

        if (tempBoard[row][col] !== 0) {
          const tempValue = tempBoard[row][col];
          tempBoard[row][col] = 0; // Temporarily remove

          // Check if the puzzle is still solvable (simple check, not uniqueness)
          let testBoard = JSON.parse(JSON.stringify(tempBoard));
          if (solve(testBoard)) {
            count++;
          } else {
            tempBoard[row][col] = tempValue; // If not solvable, put it back
          }
        }
      }
      initialBoard = JSON.parse(JSON.stringify(tempBoard)); // Store the initial puzzle
      board = JSON.parse(JSON.stringify(tempBoard)); // Set current board to the puzzle
      // Reset pencil marks for new game
      pencilMarks = Array(9).fill(0).map(() => Array(9).fill(0).map(() => new Set()));
    }

    // Helper to fill a board for generation (different from solve, ensures a full board)
    function fillBoard(currentBoard) {
        for (let i = 0; i < 81; i++) {
            let row = Math.floor(i / 9);
            let col = i % 9;
            if (currentBoard[row][col] === 0) {
                let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5); // Randomize numbers
                for (let num of numbers) {
                    if (isValid(currentBoard, row, col, num)) {
                        currentBoard[row][col] = num;
                        if (fillBoard(currentBoard)) {
                            return true;
                        } else {
                            currentBoard[row][col] = 0; // Backtrack
                        }
                    }
                }
                return false;
            }
        }
        return true;
    }


    // --- Game Initialization ---
    function initializeGame() {
      gameEnded = false;
      selectedCell = null;
      hideGameMessage();
      generateSudoku(difficulty); // Generate a new puzzle
      renderBoard();
      updateHUD();
      gameStatusEl.textContent = 'Playing'; // Reset status on new game
      pencilMode = false; // Reset manual pencil mode on new game
      autoPencilMode = false; // Reset auto pencil mode on new game
      updatePencilModeButton(); // Update button text on new game
      updateAutoPencilButton(); // Update button text on new game
    }

    // --- Rendering Functions ---
    function renderBoard() {
      sudokuBoardEl.innerHTML = ''; // Clear existing board
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const cellEl = document.createElement('div');
          cellEl.classList.add('sudoku-cell');
          cellEl.dataset.row = r;
          cellEl.dataset.col = c;

          // Add classes for 3x3 block borders
          if (r % 3 === 0 && r !== 0) {
            cellEl.style.borderTopWidth = '2px';
            cellEl.style.borderTopColor = '#555';
          }
          if (c % 3 === 0 && c !== 0) {
            cellEl.style.borderLeftWidth = '2px';
            cellEl.style.borderLeftColor = '#555';
          }

          if (initialBoard[r][c] !== 0) {
            cellEl.textContent = initialBoard[r][c];
            cellEl.classList.add('fixed'); // Fixed numbers cannot be changed
          } else if (board[r][c] !== 0) {
            cellEl.textContent = board[r][c];
            // If a main number is present, clear pencil marks for that cell
            pencilMarks[r][c].clear();
          } else {
            // Render pencil marks if no main number is present
            const pencilMarksContainer = document.createElement('div');
            pencilMarksContainer.classList.add('pencil-marks');
            // Sort pencil marks for consistent display
            const sortedPencilMarks = Array.from(pencilMarks[r][c]).sort((a, b) => a - b);
            
            // Only append pencil marks if there are any
            if (sortedPencilMarks.length > 0) {
                for (let i = 1; i <= 9; i++) {
                    const markEl = document.createElement('div');
                    if (sortedPencilMarks.includes(i)) {
                        markEl.textContent = i;
                    }
                    pencilMarksContainer.appendChild(markEl);
                }
                cellEl.appendChild(pencilMarksContainer);
            }
            // If no main number and no pencil marks, leave cell empty (no NaN)
          }

          cellEl.addEventListener('click', handleCellClick);
          sudokuBoardEl.appendChild(cellEl);
        }
      }
      highlightSelectedCell();
    }

    function highlightSelectedCell() {
        document.querySelectorAll('.sudoku-cell').forEach(cellEl => {
            cellEl.classList.remove('selected', 'invalid', 'highlight-same-value', 'highlight-group');
        });

        if (selectedCell) {
            const { row, col } = selectedCell;
            const selectedEl = document.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${col}"]`);
            if (selectedEl) {
                selectedEl.classList.add('selected');
            }

            // Highlight row, column, and 3x3 block
            for (let i = 0; i < 9; i++) {
                document.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${i}"]`).classList.add('highlight-group');
                document.querySelector(`.sudoku-cell[data-row="${i}"][data-col="${col}"]`).classList.add('highlight-group');
            }
            const startRow = row - (row % 3);
            const startCol = col - (col % 3);
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    document.querySelector(`.sudoku-cell[data-row="${i + startRow}"][data-col="${j + startCol}"]`).classList.add('highlight-group');
                }
            }

            // Highlight cells with the same value as the selected cell (if it has a value)
            const selectedValue = board[row][col];
            if (selectedValue !== 0) {
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (board[r][c] === selectedValue) {
                            document.querySelector(`.sudoku-cell[data-row="${r}"][data-col="${c}"]`).classList.add('highlight-same-value');
                        }
                    }
                }
            }
        }
    }

    function updateHUD() {
      currentDifficultyEl.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
    }

    // Function to display messages. If isGameOver is true, message persists.
    function displayGameMessage(message, isGameOver = false) {
      clearTimeout(messageTimeoutId); // Clear any existing timeout
      messageTimeoutId = null;

      gameMessageEl.textContent = message;
      gameMessageEl.style.display = 'block';
      if (isGameOver) {
        gameMessageEl.classList.add('game-over-style'); // Add style for game over
      } else {
        gameMessageEl.classList.remove('game-over-style'); // Remove style for temporary messages
        messageTimeoutId = setTimeout(hideGameMessage, 2000); // Hide temporary messages after 2 seconds
      }
    }

    function hideGameMessage() {
      gameMessageEl.style.display = 'none';
      gameMessageEl.classList.remove('game-over-style'); // Ensure style is removed when hidden
    }

    // --- Game Logic ---
    function handleCellClick(event) {
      if (gameEnded) {
        displayGameMessage("Game over! Start a New Game.");
        return;
      }

      const row = parseInt(event.currentTarget.dataset.row);
      const col = parseInt(event.currentTarget.dataset.col);

      if (initialBoard[row][col] !== 0) {
        selectedCell = null; // Cannot select fixed cells
        displayGameMessage("This is a fixed number!");
      } else {
        selectedCell = { row, col };
      }
      highlightSelectedCell();
    }

    // Helper to calculate possible numbers for a given cell
    function calculatePossibleNumbers(currentBoard, row, col) {
        const possibilities = new Set();
        for (let num = 1; num <= 9; num++) {
            if (isValid(currentBoard, row, col, num)) {
                possibilities.add(num);
            }
        }
        return possibilities;
    }

    // Function to update all pencil marks on the board (for auto-pencil)
    function updateAllPencilMarks() {
        // Clear all existing pencil marks first
        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                pencilMarks[r][c].clear();
            }
        }

        if (autoPencilMode) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) { // Only for empty cells
                        const candidates = calculatePossibleNumbers(board, r, c);
                        candidates.forEach(num => pencilMarks[r][c].add(num));
                    }
                }
            }
        }
        renderBoard(); // Re-render to show updated pencil marks
    }

    function handleNumberInput(event) {
      if (!selectedCell || gameEnded) return;

      const value = event.target.dataset.value;
      const { row, col } = selectedCell;

      if (initialBoard[row][col] !== 0) { // Cannot change fixed cells
        displayGameMessage("Cannot change fixed numbers!");
        return;
      }

      if (pencilMode) {
        // Manual Pencil mode logic
        if (value === 'clear') {
          pencilMarks[row][col].clear(); // Clear all pencil marks
        } else {
          const num = parseInt(value);
          if (pencilMarks[row][col].has(num)) {
            pencilMarks[row][col].delete(num); // Toggle off
          } else {
            pencilMarks[row][col].add(num); // Toggle on
          }
        }
        board[row][col] = 0; // Ensure main number is cleared in manual pencil mode
      } else {
        // Normal input mode logic (or if autoPencilMode is active)
        if (value === 'clear') {
          board[row][col] = 0;
        } else {
          const num = parseInt(value);
          board[row][col] = num;
          pencilMarks[row][col].clear(); // Clear pencil marks when setting a main number
        }
      }

      renderBoard(); // Re-render board to show changes

      // If auto pencil mode is active, update all pencil marks after any input
      if (autoPencilMode) {
          updateAllPencilMarks();
      }

      // Validate the current input if it's not a clear and not in any pencil mode
      if (value !== 'clear' && !pencilMode && !autoPencilMode) {
        if (!isValid(board, row, col, board[row][col])) {
          document.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${col}"]`).classList.add('invalid');
          displayGameMessage("Invalid move!");
        } else {
          // If valid, check for win condition
          if (checkWin()) {
            displayGameMessage("Congratulations! You solved the Sudoku!", true);
            gameStatusEl.textContent = 'Solved!';
            gameEnded = true;
          } else {
            gameStatusEl.textContent = 'Playing';
          }
        }
      } else if (pencilMode) {
          gameStatusEl.textContent = 'Pencil Mode Active';
      } else {
          gameStatusEl.textContent = 'Playing';
      }
    }


    function checkWin() {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] === 0 || !isValid(board, r, c, board[r][c])) {
            return false;
          }
        }
      }
      return true;
    }

    function solveCurrentPuzzle() {
        if (gameEnded) {
            displayGameMessage("Game over! Start a New Game to solve a new puzzle.");
            return;
        }
        // Use the stored solution to fill the board
        board = JSON.parse(JSON.stringify(solution));
        pencilMarks = Array(9).fill(0).map(() => Array(9).fill(0).map(() => new Set())); // Clear pencil marks
        renderBoard();
        updateHUD();
        displayGameMessage("Puzzle solved!", true);
        gameStatusEl.textContent = 'Solved!';
        gameEnded = true;
        selectedCell = null; // Deselect any cell
    }

    // Function to update the manual pencil mode button's text and active state
    function updatePencilModeButton() {
        if (pencilMode) {
            pencilModeBtn.classList.add('active-mode');
            pencilModeBtn.textContent = '✏️ Pencil Mode ON';
        } else {
            pencilModeBtn.classList.remove('active-mode');
            pencilModeBtn.textContent = '✏️ Pencil Mode OFF';
        }
        // Deselect cell when toggling pencil mode OFF
        if (!pencilMode && selectedCell) {
            selectedCell = null;
            highlightSelectedCell(); // Re-render to remove selection highlight
        }
    }

    // New: Function to update the auto pencil mode button's text and active state
    function updateAutoPencilButton() {
        if (autoPencilMode) {
            autoPencilBtn.classList.add('active-mode');
            autoPencilBtn.textContent = '📝 Auto Pencil ON';
        } else {
            autoPencilBtn.classList.remove('active-mode');
            autoPencilBtn.textContent = '📝 Auto Pencil OFF';
        }
        // Deselect cell when toggling auto pencil mode OFF
        if (!autoPencilMode && selectedCell) {
            selectedCell = null;
            highlightSelectedCell(); // Re-render to remove selection highlight
        }
    }


    // --- Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
      newGameBtn.addEventListener('click', initializeGame);
      solveBtn.addEventListener('click', solveCurrentPuzzle);

      pencilModeBtn.addEventListener('click', () => {
        pencilMode = !pencilMode;
        if (pencilMode) { // If manual pencil mode is turned ON, turn auto pencil mode OFF
            autoPencilMode = false;
            updateAllPencilMarks(); // Clear auto-generated marks
        }
        updatePencilModeButton(); // Update button text and style immediately
        updateAutoPencilButton(); // Ensure auto pencil button is updated
        // Removed: gameStatusEl.textContent = pencilMode ? 'Pencil Mode Active' : 'Playing';
        gameStatusEl.textContent = 'Playing'; // Always set to Playing for consistency
      });

      autoPencilBtn.addEventListener('click', () => {
        autoPencilMode = !autoPencilMode;
        if (autoPencilMode) { // If auto pencil mode is turned ON, turn manual pencil mode OFF
            pencilMode = false;
        }
        updatePencilModeButton(); // Ensure manual pencil button is updated
        updateAutoPencilButton(); // Update button text and style immediately
        updateAllPencilMarks(); // Recalculate and render marks based on new autoPencilMode state
        // Removed: gameStatusEl.textContent = autoPencilMode ? 'Auto Pencil Active' : 'Playing';
        gameStatusEl.textContent = 'Playing'; // Always set to Playing for consistency
      });


      difficultySelect.addEventListener('change', (event) => {
        difficulty = event.target.value;
        initializeGame();
        displayGameMessage(`Difficulty set to ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`);
      });

      numberPadEl.querySelectorAll('button').forEach(button => {
        button.addEventListener('click', handleNumberInput);
      });

      // Share and Copy Link buttons (same as Chess)
      document.getElementById('shareBtn').onclick = () => {
        if (navigator.share) {
          navigator.share({
            title: "Sudoku - No Spin Media",
            url: window.location.href
          }).catch((error) => console.error('Error sharing:', error));
        } else {
          const dummyTextArea = document.createElement('textarea');
          dummyTextArea.value = window.location.href;
          document.body.appendChild(dummyTextArea);
          dummyTextArea.select();
          document.execCommand('copy');
          document.body.removeChild(dummyTextArea);
          displayGameMessage("Link copied to clipboard!");
        }
      };
      document.getElementById('copyBtn').onclick = () => {
        const dummyTextArea = document.createElement('textarea');
        dummyTextArea.value = window.location.href;
        document.body.appendChild(dummyTextArea);
        dummyTextArea.select();
        document.execCommand('copy');
        document.body.removeChild(dummyTextArea);
        displayGameMessage("Link copied to clipboard!");
      };

      // Initial game setup
      initializeGame();
    });
  </script>
</body>
</html>
