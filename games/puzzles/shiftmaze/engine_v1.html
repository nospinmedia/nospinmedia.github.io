<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ShiftMaze: The Puzzle</title>
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        /* Basic Layout */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: url('dungeon_wall_texture.jpg') no-repeat center center / cover;
            font-family: 'Press Start 2P', cursive, Arial, sans-serif;
            color: #fff;
            position: relative;
        }

        /* TV Screen (dynamic positioning) */
        #tv {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 5px;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5), 0 0 20px rgba(0,0,0,0.7);
            border: 6px solid #4a3728;
            outline: 2px solid #6b5c4f;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            transition: all 1s ease-in-out; /* Smooth transition for position/angle changes */
        }

        #tv-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'VT323', monospace;
            font-size: 1.4vw;
            line-height: 1.3;
            color: #e0e0e0;
            text-align: center;
            padding: 1%;
            position: relative;
            z-index: 2;
        }

        /* TV Reflection */
        #tv::before {
            content: "";
            position: absolute;
            top: 0;
            left: -50%;
            width: 50%;
            height: 100%;
            background: linear-gradient(120deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 80%);
            transform: skewX(-20deg);
            animation: lightSweep 12s infinite;
            z-index: 3;
        }

        @keyframes lightSweep {
            0% { left: -60%; }
            8% { left: 120%; }
            100% { left: 120%; }
        }

        /* Game UI Container - Main area for puzzles */
        #game-container {
            position: absolute;
            top: 80%; /* Moved lower */
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 30px; /* Thinner vertical padding */
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            max-width: 70%; /* Increased max-width */
            text-align: center;
            z-index: 5;
            font-family: Arial, sans-serif; /* Cleaner font */
            display: flex; /* Added flexbox to arrange items */
            flex-direction: column; /* Stack question, then controls */
            align-items: center; /* Center items horizontally */
        }

        #puzzle-question {
            font-size: 0.9vw; /* Further reduced font size */
            margin-bottom: 20px;
            max-width: 80%; /* Reduced max-width for more compact box */
            margin-left: auto;
            margin-right: auto;
        }

        /* New row for input and buttons */
        .controls-row {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center; /* Center items in the row */
            align-items: center; /* Vertically align items in the row */
            width: 100%; /* Take full width of parent */
            margin-top: 10px; /* Space from question */
        }

        #puzzle-input {
            padding: 10px;
            width: 50%; /* Adjusted width */
            max-width: 200px; /* Adjusted max-width */
            font-size: 1.2em;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #ffcc00;
            color: #fff;
            border-radius: 5px;
            text-align: center;
            margin: 5px; /* Added margin for spacing in the row */
        }

        #submit-btn, #hint-btn, #exit-btn, #skip-btn {
            padding: 8px 15px; /* Slightly reduced padding */
            margin: 5px; /* Adjusted margin for spacing in the row */
            background: #4a3728;
            color: #ffcc00;
            border: 2px solid #ffcc00;
            border-radius: 5px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            font-size: 0.75em; /* Reduced button font size by 25% */
            transition: background 0.3s ease, color 0.3s ease;
            white-space: nowrap; /* Prevent text wrapping within buttons */
        }

        #submit-btn:hover, #hint-btn:hover, #exit-btn:hover, #skip-btn:hover {
            background: #ffcc00;
            color: #4a3728;
        }

        #message {
            margin-top: 20px;
            font-size: 1.1em;
            color: #f00; /* Red for wrong, green for correct */
        }

        /* Score Display Styling */
        #score-display {
            position: absolute;
            top: 15px; /* Adjust vertical position */
            left: 60px; /* Moved right from 20px */
            background: none; /* No background, directly on wall */
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 1.2em; /* Slightly larger for visibility */
            color: #ffcc00; /* Gold color for score */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 10;
        }
        
        /* Room Sign Styling */
        #room-sign {
            position: absolute;
            top: 5%; /* Adjusted to be slightly lower, more centered with the door top */
            left: 85%; /* Adjusted to better center over the door */
            transform: translateX(-50%); /* Centering relative to its 'left' position */
            background: rgba(50, 25, 0, 0.7); /* Darker brown for sign */
            border: 4px ridge #8B4513; /* Woody/metal border */
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Creepster', cursive; /* Old tyme castle font */
            font-size: 2.2em; /* Larger font for visibility */
            color: #fdd835; /* Gold/yellow for text */
            text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
            white-space: nowrap; /* Prevent text wrap */
            z-index: 10;
            display: none; /* Hidden by default, show in debug mode */
        }
        /* Simple pegs for the sign */
        #room-sign::before, #room-sign::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            background: #5A2D0C; /* Dark brown for pegs */
            border-radius: 50%;
            top: -5px; /* Above the sign */
            z-index: 11;
            border: 1px solid #3d1f08;
        }
        #room-sign::before {
            left: 10px;
        }
        #room-sign::after {
            right: 10px;
        }

        /* Debug Input Styling */
        #debug-input {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 5px;
            font-size: 0.9em; /* Match score/room ID font size */
            z-index: 10;
            display: none; /* Hidden by default */
            color: #ffcc00; /* Highlight debug text */
        }
        #debug-input input {
            background: rgba(255,255,255,0.1);
            border: 1px solid #ffcc00;
            color: #fff;
            padding: 3px;
            width: 80px;
            margin-left: 5px;
            margin-right: 5px;
        }
        #debug-input button {
            background: #4a3728;
            color: #ffcc00;
            border: 1px solid #ffcc00;
            border-radius: 3px;
            cursor: pointer;
        }
        #version-display {
            margin-left: 10px; /* Space from debug input */
            color: #ccc; /* Slightly muted color */
        }

        /* Mouse Styling */
        #mouse {
            position: absolute;
            bottom: 8px;
            width: 120px;
            z-index: 5;
            opacity: 0.9;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.6)); /* Base shadow */
            pointer-events: none;
        }

        /* Mute Button Styling */
        #muteBtn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: #ffcc00;
            border: 2px solid #ffcc00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            transition: background 0.3s ease, color 0.3s ease;
        }

        #muteBtn:hover {
            background: #ffcc00;
            color: #4a3728;
        }
    </style>
</head>
<body>
    <div id="tv"><div id="tv-content"></div></div>

    <div id="game-container">
        <div id="puzzle-question"></div>
        <div class="controls-row"> <input type="text" id="puzzle-input" placeholder="Your answer" />
            <button id="submit-btn">Submit</button>
            <button id="hint-btn">Hint</button>
            <button id="skip-btn">Skip</button>
            <button id="exit-btn">Exit Room</button> 
        </div>
        <div id="message"></div>
    </div>

    <div id="score-display">Score: <span id="current-score">0</span> (<span id="percent-complete">0%</span> Complete)</div>
    <div id="room-sign">
        <span id="room-sign-text"></span>
    </div>
    <div id="debug-input">
        Debug ID: <input type="text" id="debug-room-id-input" />
        <button id="load-debug-room">Load</button>
        <span id="version-display">v2.2</span> </div>
    <img id="mouse" src="rat_transparent.gif" alt="mouse" />

    <audio id="bgm" src="ambient.mp3" loop autoplay></audio>
    <button id="muteBtn" type="button">🔊</button>

    <script>
        const tv = document.getElementById('tv');
        const tvContent = document.getElementById('tv-content');
        const puzzleQuestion = document.getElementById('puzzle-question');
        const puzzleInput = document.getElementById('puzzle-input');
        const submitBtn = document.getElementById('submit-btn');
        const hintBtn = document.getElementById('hint-btn');
        const skipBtn = document.getElementById('skip-btn');
        const exitBtn = document.getElementById('exit-btn');
        const message = document.getElementById('message');
        const currentScoreDisplay = document.getElementById('current-score');
        const percentCompleteDisplay = document.getElementById('percent-complete');
        const roomSign = document.getElementById('room-sign');
        const roomSignText = document.getElementById('room-sign-text');
        const debugInputDiv = document.getElementById('debug-input');
        const debugRoomIdInput = document.getElementById('debug-room-id-input');
        const loadDebugRoomBtn = document.getElementById('load-debug-room');
        const mouse = document.getElementById('mouse');
        const versionDisplay = document.getElementById('version-display');

        let allPuzzles = [];
        let currentPuzzleIndex = -1;
        let score = 0;
        let completedPuzzles = [];
        const GAME_STATE_KEY = 'shiftmazeGameState';
        const DEBUG_MODE = true;
        const GAME_VERSION = '2.2'; // Updated: Incremented game version

        // --- TV Messages (can be separate JSON or hardcoded) ---
        const entryMessages = [
            "Did you know? All content is AI-created at nospin.media!",
            "Explore fun AI-generated games at nospin.media!"
        ];
        let allTvMessages = [];
        let tvMsgIndex = 0;

        function formatTvMessage(msg) {
            const totalDisplayLines = 6;
            const lines = msg.split("\n");
            const padding = Math.max(0, totalDisplayLines - lines.length);
            const topPadding = Math.floor(padding / 2);
            const bottomPadding = padding - topPadding;

            let html = "";
            for (let i = 0; i < topPadding; i++) html += "<div>&nbsp;</div>";
            lines.forEach(line => html += `<div>${line}</div>`);
            for (let i = 0; i < bottomPadding; i++) html += "<div>&nbsp;</div>";
            return html;
        }

        // --- Game State Management ---
        function saveGameState() {
            const gameState = {
                currentPuzzleIndex: currentPuzzleIndex,
                score: score,
                completedPuzzles: completedPuzzles
            };
            localStorage.setItem(GAME_STATE_KEY, JSON.stringify(gameState));
        }

        function loadGameState() {
            const savedState = localStorage.getItem(GAME_STATE_KEY);
            if (savedState) {
                const gameState = JSON.parse(savedState);
                score = gameState.score || 0;
                // Check if currentPuzzleIndex is valid given allPuzzles length
                if (gameState.currentPuzzleIndex !== undefined && gameState.currentPuzzleIndex >= 0 && gameState.currentPuzzleIndex < allPuzzles.length) {
                    currentPuzzleIndex = gameState.currentPuzzleIndex;
                } else {
                    currentPuzzleIndex = -1; // Reset if invalid index
                }
                completedPuzzles = gameState.completedPuzzles || [];
            }
            updateScoreDisplay(); // Update score and percentage on load
        }

        function updateScoreDisplay() {
            currentScoreDisplay.textContent = score;
            if (allPuzzles.length > 0) {
                const percentage = Math.floor((completedPuzzles.length / allPuzzles.length) * 100);
                percentCompleteDisplay.textContent = `${percentage}%`;
            } else {
                percentCompleteDisplay.textContent = '0%';
            }
        }

        // --- Puzzle Loading and Display ---
        function loadPuzzle(puzzle) {
            currentPuzzleIndex = allPuzzles.indexOf(puzzle);
            puzzleQuestion.textContent = puzzle.puzzle.question;
            puzzleInput.value = '';
            message.textContent = '';
            
            const roomIdNumber = puzzle.id.replace('room', '').replace(/^0+/, '');
            roomSignText.textContent = `ROOM: ${roomIdNumber} - ${puzzle.name.toUpperCase()}`;
            roomSign.style.display = 'block'; // Make sure the sign is visible

            const tvProps = puzzle.tvPosition || {};
            tv.style.top = tvProps.top || `${20 + Math.random() * 30}%`;
            tv.style.left = tvProps.left || `${Math.random() * 35}%`;
            tv.style.width = tvProps.width || `${18 + Math.random() * 5}%`;
            tv.style.height = tvProps.height || `${22 + Math.random() * 5}%`;
            tv.style.transform = tvProps.transform || `rotate(${Math.random() * 20 - 10}deg)`;

            document.body.style.backgroundImage = `url('${puzzle.background}')`;
            saveGameState(); // Save state whenever a new puzzle is loaded
            updateScoreDisplay(); // Update display after loading a puzzle
        }

        function loadRandomPuzzle() {
            if (allPuzzles.length === 0) {
                message.textContent = "No puzzles loaded!";
                return;
            }

            // Filter out completed puzzles
            const availablePuzzles = allPuzzles.filter(p => !completedPuzzles.includes(p.id));

            if (availablePuzzles.length === 0) {
                // All puzzles completed!
                message.textContent = "Congratulations! You've completed all puzzles! Starting over...";
                message.style.color = '#0ff';
                score = 0; // Reset score
                completedPuzzles = []; // Reset completed puzzles
                updateScoreDisplay(); // Update display
                saveGameState();
                setTimeout(loadRandomPuzzle, 3000); // Start over after a delay
                return;
            }

            let randomIndex = Math.floor(Math.random() * availablePuzzles.length);
            
            // Get the actual puzzle object from allPuzzles based on the availablePuzzles selection
            const puzzleToLoad = allPuzzles.find(p => p.id === availablePuzzles[randomIndex].id);

            if (puzzleToLoad) {
                loadPuzzle(puzzleToLoad);
            } else {
                console.error("Failed to find puzzle from available list:", availablePuzzles[randomIndex]);
                // Fallback to loading a truly random one if something went wrong
                loadPuzzle(allPuzzles[Math.floor(Math.random() * allPuzzles.length)]);
            }
            // saveGameState() is called inside loadPuzzle()
        }

        function checkAnswer() {
            const userAnswer = puzzleInput.value.trim().toLowerCase();
            const currentPuzzle = allPuzzles[currentPuzzleIndex];
            const correctAnswer = currentPuzzle.puzzle.answer.toLowerCase();

            if (userAnswer === correctAnswer) {
                message.textContent = "Correct! Moving to next room...";
                message.style.color = '#0f0'; // Green
                score += 10; // Award points
                
                // Add puzzle ID to completed puzzles if not already there
                if (!completedPuzzles.includes(currentPuzzle.id)) {
                    completedPuzzles.push(currentPuzzle.id);
                }
                updateScoreDisplay(); // Update display
                saveGameState(); // Save state after completing a puzzle

                // Check if all puzzles are now completed
                if (completedPuzzles.length === allPuzzles.length) {
                    message.textContent = "Congratulations! You've completed all puzzles! Starting over...";
                    message.style.color = '#0ff';
                    score = 0;
                    completedPuzzles = [];
                    updateScoreDisplay(); // Update display
                    saveGameState();
                    setTimeout(loadRandomPuzzle, 3000); // Start over after a delay
                } else {
                    setTimeout(loadRandomPuzzle, 1500); // Load new puzzle after a short delay
                }
            } else {
                message.textContent = "Incorrect. Try again!";
                message.style.color = '#f00'; // Red
            }
        }

        function showHint() {
            const hint = allPuzzles[currentPuzzleIndex].puzzle.hint;
            if (hint) {
                message.textContent = `Hint: ${hint}`;
                message.style.color = '#ffcc00'; // Gold for hint
                score = Math.max(0, score - 2); // Deduct points for hint
                updateScoreDisplay(); // Update display
                saveGameState(); // Save state after taking a hint
            } else {
                message.textContent = "No hint available for this puzzle.";
                message.style.color = '#fff';
            }
        }

        function skipPuzzle() {
            message.textContent = "Puzzle skipped. Loading a new room...";
            message.style.color = '#fdd835'; // Yellow/Gold for skip message
            score = Math.max(0, score - 1); // Optional: deduct minimal points for skipping
            updateScoreDisplay(); // Update display
            // Do NOT add to completedPuzzles
            saveGameState(); // Save state
            setTimeout(loadRandomPuzzle, 1000); // Load new puzzle
        }

        // --- Running Mouse Logic ---
        const colors = [
            'brightness(1.5)',
            'brightness(2)',
            'invert(1) hue-rotate(180deg) brightness(1.5)',
            'sepia(1) saturate(3) hue-rotate(50deg) brightness(1.2)'
        ];

        function runMouse() {
            const screenWidth = window.innerWidth;
            const goingRight = Math.random() > 0.5;
            mouse.style.filter = `drop-shadow(2px 2px 2px rgba(0,0,0,0.6)) ${colors[Math.floor(Math.random()*colors.length)]}`;

            if (goingRight) {
                mouse.style.left = '-140px';
                mouse.style.transform = "scaleX(-1)";
                mouse.animate([{ left: '-140px' }, { left: screenWidth + 'px' }], { duration: 7000, fill: 'forwards' });
            } else {
                mouse.style.left = screenWidth + 'px';
                mouse.style.transform = "scaleX(1)";
                mouse.animate([{ left: screenWidth + 'px' }, { left: '-140px' }], { duration: 7000, fill: 'forwards' });
            }

            setTimeout(runMouse, 15000 + Math.random()*4000);
        }

        // --- Event Listeners ---
        submitBtn.addEventListener('click', checkAnswer);
        puzzleInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                checkAnswer();
            }
        });
        hintBtn.addEventListener('click', showHint);
        skipBtn.addEventListener('click', skipPuzzle);
        
        exitBtn.addEventListener('click', () => {
            window.location.href = 'index.html'; 
        });

        loadDebugRoomBtn.addEventListener('click', () => {
            const debugId = debugRoomIdInput.value.trim();
            const puzzleToLoad = allPuzzles.find(p => p.id === debugId);
            if (puzzleToLoad) {
                loadPuzzle(puzzleToLoad);
                message.textContent = `Loaded room: ${debugId}`;
                message.style.color = '#0ff';
            } else {
                message.textContent = `Room ID "${debugId}" not found.`;
                message.style.color = '#f00';
            }
        });

        // --- Audio Control ---
        const audio = document.getElementById('bgm');
        const muteBtn = document.getElementById('muteBtn');

        document.addEventListener('click', () => {
            if (audio.paused && !audio.muted) {
                audio.play().catch(e => console.log("Autoplay blocked, user interaction needed:", e));
            }
        }, { once: true });

        setTimeout(() => {
            if (audio.paused && !audio.muted) {
                muteBtn.textContent = "🔇";
            }
        }, 500);

        muteBtn.addEventListener('click', () => {
            if (audio.paused && !audio.muted) {
                audio.play().catch(e => console.log("Autoplay blocked:", e));
                audio.muted = false;
                muteBtn.textContent = "🔊";
            } else {
                audio.muted = !audio.muted;
                muteBtn.textContent = audio.muted ? "🔇" : "🔊";
                if (!audio.muted && audio.paused) {
                    audio.play().catch(e => console.log("Autoplay blocked on unmute:", e));
                }
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            versionDisplay.textContent = `v${GAME_VERSION}`;

            fetch('tv_messages.json')
                .then(res => res.json())
                .then(data => {
                    allTvMessages = [...entryMessages, ...data];
                    tvContent.innerHTML = formatTvMessage(allTvMessages[0]);
                    setInterval(() => {
                        tvMsgIndex = (tvMsgIndex + 1) % allTvMessages.length;
                        tvContent.innerHTML = formatTvMessage(allTvMessages[tvMsgIndex]);
                    }, 9000);
                })
                .catch(err => {
                    console.error('Failed to load tv_messages.json, using default messages.', err);
                    allTvMessages = entryMessages;
                    tvContent.innerHTML = formatTvMessage(allTvMessages[0]);
                    setInterval(() => {
                        tvMsgIndex = (tvMsgIndex + 1) % allTvMessages.length;
                        tvContent.innerHTML = formatTvMessage(allTvMessages[tvMsgIndex]);
                    }, 9000);
                });

            fetch('puzzles.json')
                .then(res => res.json())
                .then(data => {
                    allPuzzles = data;
                    loadGameState(); // Load score, currentPuzzleIndex, and completedPuzzles

                    const urlParams = new URLSearchParams(window.location.search);
                    const debugId = urlParams.get('debugId');

                    if (DEBUG_MODE && debugId) {
                        const debugPuzzle = allPuzzles.find(p => p.id === debugId);
                        if (debugPuzzle) {
                            loadPuzzle(debugPuzzle);
                            message.textContent = `Debug mode: Loaded room ${debugId}`;
                            message.style.color = '#0ff';
                        } else {
                            message.textContent = `Debug ID "${debugId}" not found. Loading random.`;
                            message.style.color = '#f00';
                            loadRandomPuzzle();
                        }
                    } else if (currentPuzzleIndex !== -1 && allPuzzles[currentPuzzleIndex]) {
                                loadPuzzle(allPuzzles[currentPuzzleIndex]);
                                message.textContent = `Resumed game in room: ${allPuzzles[currentPuzzleIndex].id}`;
                                message.style.color = '#0f0';
                    }
                    else {
                        loadRandomPuzzle();
                    }

                    if (DEBUG_MODE) {
                        debugInputDiv.style.display = 'block';
                        roomSign.style.display = 'block';
                    }
                    updateScoreDisplay(); // Initial update after puzzles are loaded
                })
                .catch(err => {
                    console.error('Failed to load puzzles.json:', err);
                    message.textContent = "Error loading puzzles. Please check 'puzzles.json'.";
                    message.style.color = '#f00';
                });

            setTimeout(runMouse, 2000);
        });
    </script>
</body>
</html>
